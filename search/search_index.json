{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Landing Zone Detection Determine which of the reachable detected landing zones is closest to the person. List Number : X Discipline Subject : Graphs II Students Number Student 17/0146251 Jo\u00e3o Lucas Zarbi\u00e9lli 19/0046945 Leonardo Michalski Miranda About App Gif Video (pt-br, download link ) How to run Language : Python. Frameworks : OpenCV; Jupyter Voil\u00e0; BinderHub. Access the app or the notebook with the BinderHub server. How to use References Jupyter et al., \"Binder 2.0 - Reproducible, Interactive, Sharable Environments for Science at Scale.\" Proceedings of the 17th Python in Science Conference. 2018. doi://10.25080/Majora-4af1f417-011","title":"Home"},{"location":"#landing-zone-detection","text":"Determine which of the reachable detected landing zones is closest to the person. List Number : X Discipline Subject : Graphs II","title":"Landing Zone Detection"},{"location":"#students","text":"Number Student 17/0146251 Jo\u00e3o Lucas Zarbi\u00e9lli 19/0046945 Leonardo Michalski Miranda","title":"Students"},{"location":"#about","text":"","title":"About"},{"location":"#app-gif","text":"","title":"App Gif"},{"location":"#video-pt-br-download-link","text":"","title":"Video (pt-br, download link)"},{"location":"#how-to-run","text":"Language : Python. Frameworks : OpenCV; Jupyter Voil\u00e0; BinderHub. Access the app or the notebook with the BinderHub server.","title":"How to run"},{"location":"#how-to-use","text":"","title":"How to use"},{"location":"#references","text":"Jupyter et al., \"Binder 2.0 - Reproducible, Interactive, Sharable Environments for Science at Scale.\" Proceedings of the 17th Python in Science Conference. 2018. doi://10.25080/Majora-4af1f417-011","title":"References"},{"location":"reference/landing_zone_detection/","text":"Module landing_zone_detection None None Sub-modules landing_zone_detection.data landing_zone_detection.graph_utils landing_zone_detection.label_utils landing_zone_detection.visualization_utils","title":"Index"},{"location":"reference/landing_zone_detection/#module-landing_zone_detection","text":"None None","title":"Module landing_zone_detection"},{"location":"reference/landing_zone_detection/#sub-modules","text":"landing_zone_detection.data landing_zone_detection.graph_utils landing_zone_detection.label_utils landing_zone_detection.visualization_utils","title":"Sub-modules"},{"location":"reference/landing_zone_detection/data/","text":"Module landing_zone_detection.data None None View Source import numpy as np import cv2 from landing_zone_detection import label_utils import os class AerialImageData ( object ): \"\"\"Short summary. Parameters ---------- frame : type Description of parameter `frame`. adj_matrix : type Description of parameter `adj_matrix`. height_map : type Description of parameter `height_map`. person_coord : type Description of parameter `person_coord`. \"\"\" def __init__ ( self , frame = None , adj_matrix = None , height_map = None , person_coord = None ): self . frame = frame self . adj_matrix = adj_matrix self . height_map = height_map self . person_coord = person_coord # UTILITIES TO GENERATE RANDOM DATA MOCK_DATA_PATH = 'mock_data' TERRAIN_OPTIONS_IMAGES = [ os . path . join ( MOCK_DATA_PATH , 'grass.png' ), os . path . join ( MOCK_DATA_PATH , 'grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'tree.png' ), os . path . join ( MOCK_DATA_PATH , 'tree_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'tree_pincushion.png' ), ] PERSON_OPTIONS_IMAGES = [ os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass_pincushion.png' ), ] TERRAIN_OPTIONS_LABELS = [ label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass_barrel label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree_barrel label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree_pincushion ] PERSON_OPTIONS_LABELS = [ label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass_pincushion ] TERRAIN_OPTIONS_HEIGHTS = [ 0 , # grass 0.8 , # grass_barrel - 1.2 , # grass_pincushion 0 , # tall_grass 0.8 , # tall_grass_barrel - 1.2 , # tall_grass_pincushion 0 , # tree 0.8 , # tree_barrel - 1.2 , # tree_pincushion ] PERSON_OPTIONS_HEIGHTS = [ 0 , # person_in_tall_grass 0.8 , # person_in_tall_grass_barrel - 1.2 , # person_in_tall_grass_pincushion 0 , # person_on_grass 0.8 , # person_on_grass_barrel - 1.2 , # person_on_grass_pincushion ] class RandomAerialImageDataGenerator ( object ): \"\"\"Short summary. Parameters ---------- width : type Description of parameter `width`. height : type Description of parameter `height`. channels : type Description of parameter `channels`. dtype : type Description of parameter `dtype`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. terrain_options_images : type Description of parameter `terrain_options_images`. terrain_options_labels : type Description of parameter `terrain_options_labels`. terrain_options_heights : type Description of parameter `terrain_options_heights`. person_options_images : type Description of parameter `person_options_images`. person_options_labels : type Description of parameter `person_options_labels`. person_options_heights : type Description of parameter `person_options_heights`. Attributes ---------- num_cols : type Description of attribute `num_cols`. num_rows : type Description of attribute `num_rows`. load_img_items : type Description of attribute `load_img_items`. \"\"\" def __init__ ( self , width = 224 , height = 224 , channels = 3 , dtype = np . uint8 , col_size = 32 , row_size = 32 , terrain_options_images = TERRAIN_OPTIONS_IMAGES , terrain_options_labels = TERRAIN_OPTIONS_LABELS , terrain_options_heights = TERRAIN_OPTIONS_HEIGHTS , person_options_images = PERSON_OPTIONS_IMAGES , person_options_labels = PERSON_OPTIONS_LABELS , person_options_heights = PERSON_OPTIONS_HEIGHTS ): self . width = width self . height = height self . channels = channels self . dtype = dtype self . col_size = col_size self . row_size = row_size self . terrain_options_images = terrain_options_images self . terrain_options_labels = terrain_options_labels self . terrain_options_heights = terrain_options_heights self . person_options_images = person_options_images self . person_options_labels = person_options_labels self . person_options_heights = person_options_heights self . num_cols = self . width // self . col_size self . num_rows = self . height // self . row_size self . terrain_options_images = self . load_img_items ( self . terrain_options_images ) self . person_options_images = self . load_img_items ( self . person_options_images ) def __read_img_item ( self , filename , ** kwargs ): \"\"\"Short summary. Parameters ---------- filename : type Description of parameter `filename`. **kwargs : type Description of parameter `**kwargs`. Returns ------- type Description of returned object. \"\"\" return cv2 . imread ( filename , ** kwargs ) def __resize_img_item ( self , img_item , resize_method = cv2 . INTER_LINEAR , ** kwargs ): \"\"\"Short summary. Parameters ---------- img_item : type Description of parameter `img_item`. resize_method : type Description of parameter `resize_method`. **kwargs : type Description of parameter `**kwargs`. Returns ------- type Description of returned object. \"\"\" return cv2 . resize ( src = img_item , dsize = ( self . col_size , self . row_size ), interpolation = resize_method , ** kwargs ) def load_img_items ( self , img_items ): \"\"\"Short summary. Parameters ---------- img_items : type Description of parameter `img_items`. Returns ------- type Description of returned object. \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items def generate ( self ): \"\"\"Short summary. Returns ------- type Description of returned object. \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ) ) # populate with the terrain options for i in range ( self . num_cols ): x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ): y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i , j ] return data Variables MOCK_DATA_PATH PERSON_OPTIONS_HEIGHTS PERSON_OPTIONS_IMAGES PERSON_OPTIONS_LABELS TERRAIN_OPTIONS_HEIGHTS TERRAIN_OPTIONS_IMAGES TERRAIN_OPTIONS_LABELS Classes AerialImageData class AerialImageData ( frame = None , adj_matrix = None , height_map = None , person_coord = None ) Attributes Name Type Description Default frame type Description of parameter frame . None adj_matrix type Description of parameter adj_matrix . None height_map type Description of parameter height_map . None person_coord type Description of parameter person_coord . None View Source class AerialImageData ( object ) : \" \"\" Short summary. Parameters ---------- frame : type Description of parameter `frame`. adj_matrix : type Description of parameter `adj_matrix`. height_map : type Description of parameter `height_map`. person_coord : type Description of parameter `person_coord`. \"\" \" def __init__ ( self , frame = None , adj_matrix = None , height_map = None , person_coord = None ) : self . frame = frame self . adj_matrix = adj_matrix self . height_map = height_map self . person_coord = person_coord RandomAerialImageDataGenerator class RandomAerialImageDataGenerator ( width = 224 , height = 224 , channels = 3 , dtype =< class ' numpy . uint8 '>, col_size = 32 , row_size = 32 , terrain_options_images = [ 'mock_data/grass.png' , 'mock_data/grass_barrel.png' , 'mock_data/grass_pincushion.png' , 'mock_data/tall_grass.png' , 'mock_data/tall_grass_barrel.png' , 'mock_data/tall_grass_pincushion.png' , 'mock_data/tree.png' , 'mock_data/tree_barrel.png' , 'mock_data/tree_pincushion.png' ], terrain_options_labels = [ 1 , 1 , 1 , 0 , 0 , 0 , - 1 , - 1 , - 1 ], terrain_options_heights = [ 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 ], person_options_images = [ 'mock_data/person_in_tall_grass.png' , 'mock_data/person_in_tall_grass_barrel.png' , 'mock_data/person_in_tall_grass_pincushion.png' , 'mock_data/person_on_grass.png' , 'mock_data/person_on_grass_barrel.png' , 'mock_data/person_on_grass_pincushion.png' ], person_options_labels = [ 0 , 0 , 0 , 0 , 0 , 0 ], person_options_heights = [ 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 ] ) Attributes Name Type Description Default width type Description of parameter width . None height type Description of parameter height . None channels type Description of parameter channels . None dtype type Description of parameter dtype . None col_size type Description of parameter col_size . None row_size type Description of parameter row_size . None terrain_options_images type Description of parameter terrain_options_images . None terrain_options_labels type Description of parameter terrain_options_labels . None terrain_options_heights type Description of parameter terrain_options_heights . None person_options_images type Description of parameter person_options_images . None person_options_labels type Description of parameter person_options_labels . None person_options_heights type Description of parameter person_options_heights . None num_cols type Description of attribute num_cols . None num_rows type Description of attribute num_rows . None load_img_items type Description of attribute load_img_items . None View Source class RandomAerialImageDataGenerator ( object ): \"\"\"Short summary. Parameters ---------- width : type Description of parameter `width`. height : type Description of parameter `height`. channels : type Description of parameter `channels`. dtype : type Description of parameter `dtype`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. terrain_options_images : type Description of parameter `terrain_options_images`. terrain_options_labels : type Description of parameter `terrain_options_labels`. terrain_options_heights : type Description of parameter `terrain_options_heights`. person_options_images : type Description of parameter `person_options_images`. person_options_labels : type Description of parameter `person_options_labels`. person_options_heights : type Description of parameter `person_options_heights`. Attributes ---------- num_cols : type Description of attribute `num_cols`. num_rows : type Description of attribute `num_rows`. load_img_items : type Description of attribute `load_img_items`. \"\"\" def __init__ ( self , width = 224 , height = 224 , channels = 3 , dtype = np . uint8 , col_size = 32 , row_size = 32 , terrain_options_images = TERRAIN_OPTIONS_IMAGES , terrain_options_labels = TERRAIN_OPTIONS_LABELS , terrain_options_heights = TERRAIN_OPTIONS_HEIGHTS , person_options_images = PERSON_OPTIONS_IMAGES , person_options_labels = PERSON_OPTIONS_LABELS , person_options_heights = PERSON_OPTIONS_HEIGHTS ): self . width = width self . height = height self . channels = channels self . dtype = dtype self . col_size = col_size self . row_size = row_size self . terrain_options_images = terrain_options_images self . terrain_options_labels = terrain_options_labels self . terrain_options_heights = terrain_options_heights self . person_options_images = person_options_images self . person_options_labels = person_options_labels self . person_options_heights = person_options_heights self . num_cols = self . width // self . col_size self . num_rows = self . height // self . row_size self . terrain_options_images = self . load_img_items ( self . terrain_options_images ) self . person_options_images = self . load_img_items ( self . person_options_images ) def __read_img_item ( self , filename , ** kwargs ): \"\"\"Short summary. Parameters ---------- filename : type Description of parameter `filename`. **kwargs : type Description of parameter `**kwargs`. Returns ------- type Description of returned object. \"\"\" return cv2 . imread ( filename , ** kwargs ) def __resize_img_item ( self , img_item , resize_method = cv2 . INTER_LINEAR , ** kwargs ): \"\"\"Short summary. Parameters ---------- img_item : type Description of parameter `img_item`. resize_method : type Description of parameter `resize_method`. **kwargs : type Description of parameter `**kwargs`. Returns ------- type Description of returned object. \"\"\" return cv2 . resize ( src = img_item , dsize = ( self . col_size , self . row_size ), interpolation = resize_method , ** kwargs ) def load_img_items ( self , img_items ): \"\"\"Short summary. Parameters ---------- img_items : type Description of parameter `img_items`. Returns ------- type Description of returned object. \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items def generate ( self ): \"\"\"Short summary. Returns ------- type Description of returned object. \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ) ) # populate with the terrain options for i in range ( self . num_cols ): x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ): y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i , j ] return data Methods generate def generate ( self ) Short summary. Returns: Type Description type Description of returned object. View Source def generate ( self ) : \"\"\"Short summary. Returns ------- type Description of returned object. \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ) ) # populate with the terrain options for i in range ( self . num_cols ) : x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ) : y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1:x2, y1:y2, : ] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1:x2, y1:y2, : ] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i, j ] return data load_img_items def load_img_items ( self , img_items ) Short summary. Parameters: Name Type Description Default img_items type Description of parameter img_items . None Returns: Type Description type Description of returned object. View Source def load_img_items ( self , img_items ): \"\"\"Short summary. Parameters ---------- img_items : type Description of parameter `img_items`. Returns ------- type Description of returned object. \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items","title":"Data"},{"location":"reference/landing_zone_detection/data/#module-landing_zone_detectiondata","text":"None None View Source import numpy as np import cv2 from landing_zone_detection import label_utils import os class AerialImageData ( object ): \"\"\"Short summary. Parameters ---------- frame : type Description of parameter `frame`. adj_matrix : type Description of parameter `adj_matrix`. height_map : type Description of parameter `height_map`. person_coord : type Description of parameter `person_coord`. \"\"\" def __init__ ( self , frame = None , adj_matrix = None , height_map = None , person_coord = None ): self . frame = frame self . adj_matrix = adj_matrix self . height_map = height_map self . person_coord = person_coord # UTILITIES TO GENERATE RANDOM DATA MOCK_DATA_PATH = 'mock_data' TERRAIN_OPTIONS_IMAGES = [ os . path . join ( MOCK_DATA_PATH , 'grass.png' ), os . path . join ( MOCK_DATA_PATH , 'grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'tree.png' ), os . path . join ( MOCK_DATA_PATH , 'tree_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'tree_pincushion.png' ), ] PERSON_OPTIONS_IMAGES = [ os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass_pincushion.png' ), ] TERRAIN_OPTIONS_LABELS = [ label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass_barrel label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree_barrel label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree_pincushion ] PERSON_OPTIONS_LABELS = [ label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass_pincushion ] TERRAIN_OPTIONS_HEIGHTS = [ 0 , # grass 0.8 , # grass_barrel - 1.2 , # grass_pincushion 0 , # tall_grass 0.8 , # tall_grass_barrel - 1.2 , # tall_grass_pincushion 0 , # tree 0.8 , # tree_barrel - 1.2 , # tree_pincushion ] PERSON_OPTIONS_HEIGHTS = [ 0 , # person_in_tall_grass 0.8 , # person_in_tall_grass_barrel - 1.2 , # person_in_tall_grass_pincushion 0 , # person_on_grass 0.8 , # person_on_grass_barrel - 1.2 , # person_on_grass_pincushion ] class RandomAerialImageDataGenerator ( object ): \"\"\"Short summary. Parameters ---------- width : type Description of parameter `width`. height : type Description of parameter `height`. channels : type Description of parameter `channels`. dtype : type Description of parameter `dtype`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. terrain_options_images : type Description of parameter `terrain_options_images`. terrain_options_labels : type Description of parameter `terrain_options_labels`. terrain_options_heights : type Description of parameter `terrain_options_heights`. person_options_images : type Description of parameter `person_options_images`. person_options_labels : type Description of parameter `person_options_labels`. person_options_heights : type Description of parameter `person_options_heights`. Attributes ---------- num_cols : type Description of attribute `num_cols`. num_rows : type Description of attribute `num_rows`. load_img_items : type Description of attribute `load_img_items`. \"\"\" def __init__ ( self , width = 224 , height = 224 , channels = 3 , dtype = np . uint8 , col_size = 32 , row_size = 32 , terrain_options_images = TERRAIN_OPTIONS_IMAGES , terrain_options_labels = TERRAIN_OPTIONS_LABELS , terrain_options_heights = TERRAIN_OPTIONS_HEIGHTS , person_options_images = PERSON_OPTIONS_IMAGES , person_options_labels = PERSON_OPTIONS_LABELS , person_options_heights = PERSON_OPTIONS_HEIGHTS ): self . width = width self . height = height self . channels = channels self . dtype = dtype self . col_size = col_size self . row_size = row_size self . terrain_options_images = terrain_options_images self . terrain_options_labels = terrain_options_labels self . terrain_options_heights = terrain_options_heights self . person_options_images = person_options_images self . person_options_labels = person_options_labels self . person_options_heights = person_options_heights self . num_cols = self . width // self . col_size self . num_rows = self . height // self . row_size self . terrain_options_images = self . load_img_items ( self . terrain_options_images ) self . person_options_images = self . load_img_items ( self . person_options_images ) def __read_img_item ( self , filename , ** kwargs ): \"\"\"Short summary. Parameters ---------- filename : type Description of parameter `filename`. **kwargs : type Description of parameter `**kwargs`. Returns ------- type Description of returned object. \"\"\" return cv2 . imread ( filename , ** kwargs ) def __resize_img_item ( self , img_item , resize_method = cv2 . INTER_LINEAR , ** kwargs ): \"\"\"Short summary. Parameters ---------- img_item : type Description of parameter `img_item`. resize_method : type Description of parameter `resize_method`. **kwargs : type Description of parameter `**kwargs`. Returns ------- type Description of returned object. \"\"\" return cv2 . resize ( src = img_item , dsize = ( self . col_size , self . row_size ), interpolation = resize_method , ** kwargs ) def load_img_items ( self , img_items ): \"\"\"Short summary. Parameters ---------- img_items : type Description of parameter `img_items`. Returns ------- type Description of returned object. \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items def generate ( self ): \"\"\"Short summary. Returns ------- type Description of returned object. \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ) ) # populate with the terrain options for i in range ( self . num_cols ): x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ): y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i , j ] return data","title":"Module landing_zone_detection.data"},{"location":"reference/landing_zone_detection/data/#variables","text":"MOCK_DATA_PATH PERSON_OPTIONS_HEIGHTS PERSON_OPTIONS_IMAGES PERSON_OPTIONS_LABELS TERRAIN_OPTIONS_HEIGHTS TERRAIN_OPTIONS_IMAGES TERRAIN_OPTIONS_LABELS","title":"Variables"},{"location":"reference/landing_zone_detection/data/#classes","text":"","title":"Classes"},{"location":"reference/landing_zone_detection/data/#aerialimagedata","text":"class AerialImageData ( frame = None , adj_matrix = None , height_map = None , person_coord = None )","title":"AerialImageData"},{"location":"reference/landing_zone_detection/data/#attributes","text":"Name Type Description Default frame type Description of parameter frame . None adj_matrix type Description of parameter adj_matrix . None height_map type Description of parameter height_map . None person_coord type Description of parameter person_coord . None View Source class AerialImageData ( object ) : \" \"\" Short summary. Parameters ---------- frame : type Description of parameter `frame`. adj_matrix : type Description of parameter `adj_matrix`. height_map : type Description of parameter `height_map`. person_coord : type Description of parameter `person_coord`. \"\" \" def __init__ ( self , frame = None , adj_matrix = None , height_map = None , person_coord = None ) : self . frame = frame self . adj_matrix = adj_matrix self . height_map = height_map self . person_coord = person_coord","title":"Attributes"},{"location":"reference/landing_zone_detection/data/#randomaerialimagedatagenerator","text":"class RandomAerialImageDataGenerator ( width = 224 , height = 224 , channels = 3 , dtype =< class ' numpy . uint8 '>, col_size = 32 , row_size = 32 , terrain_options_images = [ 'mock_data/grass.png' , 'mock_data/grass_barrel.png' , 'mock_data/grass_pincushion.png' , 'mock_data/tall_grass.png' , 'mock_data/tall_grass_barrel.png' , 'mock_data/tall_grass_pincushion.png' , 'mock_data/tree.png' , 'mock_data/tree_barrel.png' , 'mock_data/tree_pincushion.png' ], terrain_options_labels = [ 1 , 1 , 1 , 0 , 0 , 0 , - 1 , - 1 , - 1 ], terrain_options_heights = [ 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 ], person_options_images = [ 'mock_data/person_in_tall_grass.png' , 'mock_data/person_in_tall_grass_barrel.png' , 'mock_data/person_in_tall_grass_pincushion.png' , 'mock_data/person_on_grass.png' , 'mock_data/person_on_grass_barrel.png' , 'mock_data/person_on_grass_pincushion.png' ], person_options_labels = [ 0 , 0 , 0 , 0 , 0 , 0 ], person_options_heights = [ 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 ] )","title":"RandomAerialImageDataGenerator"},{"location":"reference/landing_zone_detection/data/#attributes_1","text":"Name Type Description Default width type Description of parameter width . None height type Description of parameter height . None channels type Description of parameter channels . None dtype type Description of parameter dtype . None col_size type Description of parameter col_size . None row_size type Description of parameter row_size . None terrain_options_images type Description of parameter terrain_options_images . None terrain_options_labels type Description of parameter terrain_options_labels . None terrain_options_heights type Description of parameter terrain_options_heights . None person_options_images type Description of parameter person_options_images . None person_options_labels type Description of parameter person_options_labels . None person_options_heights type Description of parameter person_options_heights . None num_cols type Description of attribute num_cols . None num_rows type Description of attribute num_rows . None load_img_items type Description of attribute load_img_items . None View Source class RandomAerialImageDataGenerator ( object ): \"\"\"Short summary. Parameters ---------- width : type Description of parameter `width`. height : type Description of parameter `height`. channels : type Description of parameter `channels`. dtype : type Description of parameter `dtype`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. terrain_options_images : type Description of parameter `terrain_options_images`. terrain_options_labels : type Description of parameter `terrain_options_labels`. terrain_options_heights : type Description of parameter `terrain_options_heights`. person_options_images : type Description of parameter `person_options_images`. person_options_labels : type Description of parameter `person_options_labels`. person_options_heights : type Description of parameter `person_options_heights`. Attributes ---------- num_cols : type Description of attribute `num_cols`. num_rows : type Description of attribute `num_rows`. load_img_items : type Description of attribute `load_img_items`. \"\"\" def __init__ ( self , width = 224 , height = 224 , channels = 3 , dtype = np . uint8 , col_size = 32 , row_size = 32 , terrain_options_images = TERRAIN_OPTIONS_IMAGES , terrain_options_labels = TERRAIN_OPTIONS_LABELS , terrain_options_heights = TERRAIN_OPTIONS_HEIGHTS , person_options_images = PERSON_OPTIONS_IMAGES , person_options_labels = PERSON_OPTIONS_LABELS , person_options_heights = PERSON_OPTIONS_HEIGHTS ): self . width = width self . height = height self . channels = channels self . dtype = dtype self . col_size = col_size self . row_size = row_size self . terrain_options_images = terrain_options_images self . terrain_options_labels = terrain_options_labels self . terrain_options_heights = terrain_options_heights self . person_options_images = person_options_images self . person_options_labels = person_options_labels self . person_options_heights = person_options_heights self . num_cols = self . width // self . col_size self . num_rows = self . height // self . row_size self . terrain_options_images = self . load_img_items ( self . terrain_options_images ) self . person_options_images = self . load_img_items ( self . person_options_images ) def __read_img_item ( self , filename , ** kwargs ): \"\"\"Short summary. Parameters ---------- filename : type Description of parameter `filename`. **kwargs : type Description of parameter `**kwargs`. Returns ------- type Description of returned object. \"\"\" return cv2 . imread ( filename , ** kwargs ) def __resize_img_item ( self , img_item , resize_method = cv2 . INTER_LINEAR , ** kwargs ): \"\"\"Short summary. Parameters ---------- img_item : type Description of parameter `img_item`. resize_method : type Description of parameter `resize_method`. **kwargs : type Description of parameter `**kwargs`. Returns ------- type Description of returned object. \"\"\" return cv2 . resize ( src = img_item , dsize = ( self . col_size , self . row_size ), interpolation = resize_method , ** kwargs ) def load_img_items ( self , img_items ): \"\"\"Short summary. Parameters ---------- img_items : type Description of parameter `img_items`. Returns ------- type Description of returned object. \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items def generate ( self ): \"\"\"Short summary. Returns ------- type Description of returned object. \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ) ) # populate with the terrain options for i in range ( self . num_cols ): x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ): y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i , j ] return data","title":"Attributes"},{"location":"reference/landing_zone_detection/data/#methods","text":"","title":"Methods"},{"location":"reference/landing_zone_detection/data/#generate","text":"def generate ( self ) Short summary. Returns: Type Description type Description of returned object. View Source def generate ( self ) : \"\"\"Short summary. Returns ------- type Description of returned object. \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ) ) # populate with the terrain options for i in range ( self . num_cols ) : x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ) : y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1:x2, y1:y2, : ] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1:x2, y1:y2, : ] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i, j ] return data","title":"generate"},{"location":"reference/landing_zone_detection/data/#load_img_items","text":"def load_img_items ( self , img_items ) Short summary. Parameters: Name Type Description Default img_items type Description of parameter img_items . None Returns: Type Description type Description of returned object. View Source def load_img_items ( self , img_items ): \"\"\"Short summary. Parameters ---------- img_items : type Description of parameter `img_items`. Returns ------- type Description of returned object. \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items","title":"load_img_items"},{"location":"reference/landing_zone_detection/graph_utils/","text":"Module landing_zone_detection.graph_utils None None View Source import numpy as np from landing_zone_detection.label_utils import can_a_person_reach , can_uav_land def do_coord_exist ( coord , matrix_shape ): \"\"\"Check if a 2D coordinate isn't out of bounds. Parameters ---------- coord : ndarray Description of parameter `coord`. matrix_shape : ndarray Description of parameter `matrix_shape`. Returns ------- bool Whether the coordinate exists. \"\"\" return np . bitwise_and ( coord < matrix_shape , coord >= 0 ) . all () def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ): \"\"\"Short summary. Parameters ---------- x1 : type Description of parameter `x1`. y1 : type Description of parameter `y1`. z1 : type Description of parameter `z1`. x2 : type Description of parameter `x2`. y2 : type Description of parameter `y2`. z2 : type Description of parameter `z2`. Returns ------- type Description of returned object. \"\"\" return (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) ** ( 1 / 2 ) def hashable_coord ( coord ): \"\"\"Short summary. Parameters ---------- coord : type Description of parameter `coord`. Returns ------- type Description of returned object. \"\"\" return str ( coord ) def find_landing_zone ( data ): \"\"\"Short summary. Parameters ---------- data : type Description of parameter `data`. Returns ------- type Description of returned object. \"\"\" shortest_paths_dict = {} person_coord_hash = hashable_coord ( data . person_coord ) shortest_paths_dict [ person_coord_hash ] = {} shortest_paths_dict [ person_coord_hash ][ 'path' ] = [ data . person_coord ] shortest_paths_dict [ person_coord_hash ][ 'distance' ] = 0 base_neighbours = np . asarray ([[ 1 , 0 ], [ 0 , 1 ], [ 1 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ], [ - 1 , - 1 ], [ - 1 , 1 ], [ 1 , - 1 ]]) find_landing_zone_re ( data . person_coord , data , shortest_paths_dict , base_neighbours ) del shortest_paths_dict [ person_coord_hash ] for value in shortest_paths_dict . values (): if not value [ 'can_uav_land' ]: continue if 'shortest_distance' not in locals (): shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] continue if shortest_distance > value [ 'distance' ]: shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] if 'shortest_distance' in locals (): return shortest_path , shortest_distance else : return [], - 1 def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ): \"\"\"Short summary. Parameters ---------- current_coord : type Description of parameter `current_coord`. data : type Description of parameter `data`. shortest_paths_dict : type Description of parameter `shortest_paths_dict`. base_neighbours : type Description of parameter `base_neighbours`. Returns ------- type Description of returned object. \"\"\" current_coord_hash = hashable_coord ( current_coord ) current_height = data . height_map [ current_coord [ 0 ]][ current_coord [ 1 ]] current_item = shortest_paths_dict [ current_coord_hash ] neighbour_list = base_neighbours + np . asarray ( current_coord ) for nb_coord in neighbour_list : # ignore coords that do not exist i.e (-1, 99999999) if not do_coord_exist ( nb_coord , data . adj_matrix . shape ): continue nb_label = data . adj_matrix [ nb_coord [ 0 ]][ nb_coord [ 1 ]] # ignore unreachable coords if not can_a_person_reach ( nb_label ): continue nb_coord_hashable = hashable_coord ( nb_coord ) nb_height = data . height_map [ nb_coord [ 0 ]][ nb_coord [ 1 ]] nb_distance = current_item [ 'distance' ] + \\ distance_between_3d_points ( current_coord [ 0 ], current_coord [ 1 ], abs ( current_height ), nb_coord [ 0 ], nb_coord [ 1 ], abs ( nb_height ) ) if nb_coord_hashable not in shortest_paths_dict : shortest_paths_dict [ nb_coord_hashable ] = {} else : if nb_distance > shortest_paths_dict [ nb_coord_hashable ][ 'distance' ]: continue nb_coord_item = shortest_paths_dict [ nb_coord_hashable ] nb_coord_item [ 'distance' ] = nb_distance nb_coord_item [ 'path' ] = shortest_paths_dict [ current_coord_hash ][ 'path' ][:] nb_coord_item [ 'path' ] . append ( nb_coord ) if can_uav_land ( nb_label ): nb_coord_item [ 'can_uav_land' ] = True else : nb_coord_item [ 'can_uav_land' ] = False find_landing_zone_re ( nb_coord , data , shortest_paths_dict , base_neighbours ) Functions distance_between_3d_points def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ) Short summary. Parameters: Name Type Description Default x1 type Description of parameter x1 . None y1 type Description of parameter y1 . None z1 type Description of parameter z1 . None x2 type Description of parameter x2 . None y2 type Description of parameter y2 . None z2 type Description of parameter z2 . None Returns: Type Description type Description of returned object. View Source def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ) : \" \"\" Short summary. Parameters ---------- x1 : type Description of parameter `x1`. y1 : type Description of parameter `y1`. z1 : type Description of parameter `z1`. x2 : type Description of parameter `x2`. y2 : type Description of parameter `y2`. z2 : type Description of parameter `z2`. Returns ------- type Description of returned object. \"\" \" return (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) ** ( 1 / 2 ) do_coord_exist def do_coord_exist ( coord , matrix_shape ) Check if a 2D coordinate isn't out of bounds. Parameters: Name Type Description Default coord ndarray Description of parameter coord . None matrix_shape ndarray Description of parameter matrix_shape . None Returns: Type Description bool Whether the coordinate exists. View Source def do_coord_exist ( coord , matrix_shape ) : \" \"\" Check if a 2D coordinate isn't out of bounds. Parameters ---------- coord : ndarray Description of parameter `coord`. matrix_shape : ndarray Description of parameter `matrix_shape`. Returns ------- bool Whether the coordinate exists. \"\" \" return np . bitwise_and ( coord < matrix_shape , coord >= 0 ). all () find_landing_zone def find_landing_zone ( data ) Short summary. Parameters: Name Type Description Default data type Description of parameter data . None Returns: Type Description type Description of returned object. View Source def find_landing_zone ( data ) : \"\"\"Short summary. Parameters ---------- data : type Description of parameter `data`. Returns ------- type Description of returned object. \"\"\" shortest_paths_dict = {} person_coord_hash = hashable_coord ( data . person_coord ) shortest_paths_dict [ person_coord_hash ] = {} shortest_paths_dict [ person_coord_hash ][ 'path' ] = [ data.person_coord ] shortest_paths_dict [ person_coord_hash ][ 'distance' ] = 0 base_neighbours = np . asarray ( [ [1, 0 ] , [ 0, 1 ] , [ 1, 1 ] , [ -1, 0 ] , [ 0, -1 ] , [ -1, -1 ] , [ -1, 1 ] , [ 1, -1 ] ] ) find_landing_zone_re ( data . person_coord , data , shortest_paths_dict , base_neighbours ) del shortest_paths_dict [ person_coord_hash ] for value in shortest_paths_dict . values () : if not value [ 'can_uav_land' ] : continue if 'shortest_distance' not in locals () : shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] continue if shortest_distance > value [ 'distance' ] : shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] if 'shortest_distance' in locals () : return shortest_path , shortest_distance else : return [] , - 1 find_landing_zone_re def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ) Short summary. Parameters: Name Type Description Default current_coord type Description of parameter current_coord . None data type Description of parameter data . None shortest_paths_dict type Description of parameter shortest_paths_dict . None base_neighbours type Description of parameter base_neighbours . None Returns: Type Description type Description of returned object. View Source def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ) : \"\"\"Short summary. Parameters ---------- current_coord : type Description of parameter `current_coord`. data : type Description of parameter `data`. shortest_paths_dict : type Description of parameter `shortest_paths_dict`. base_neighbours : type Description of parameter `base_neighbours`. Returns ------- type Description of returned object. \"\"\" current_coord_hash = hashable_coord ( current_coord ) current_height = data . height_map [ current_coord[0 ] ] [ current_coord[1 ] ] current_item = shortest_paths_dict [ current_coord_hash ] neighbour_list = base_neighbours + np . asarray ( current_coord ) for nb_coord in neighbour_list : # ignore coords that do not exist i . e ( - 1 , 99999999 ) if not do_coord_exist ( nb_coord , data . adj_matrix . shape ) : continue nb_label = data . adj_matrix [ nb_coord[0 ] ] [ nb_coord[1 ] ] # ignore unreachable coords if not can_a_person_reach ( nb_label ) : continue nb_coord_hashable = hashable_coord ( nb_coord ) nb_height = data . height_map [ nb_coord[0 ] ] [ nb_coord[1 ] ] nb_distance = current_item [ 'distance' ] + \\ distance_between_3d_points ( current_coord [ 0 ] , current_coord [ 1 ] , abs ( current_height ), nb_coord [ 0 ] , nb_coord [ 1 ] , abs ( nb_height ) ) if nb_coord_hashable not in shortest_paths_dict : shortest_paths_dict [ nb_coord_hashable ] = {} else : if nb_distance > shortest_paths_dict [ nb_coord_hashable ][ 'distance' ] : continue nb_coord_item = shortest_paths_dict [ nb_coord_hashable ] nb_coord_item [ 'distance' ] = nb_distance nb_coord_item [ 'path' ] = shortest_paths_dict [ current_coord_hash ][ 'path' ][ : ] nb_coord_item [ 'path' ] . append ( nb_coord ) if can_uav_land ( nb_label ) : nb_coord_item [ 'can_uav_land' ] = True else : nb_coord_item [ 'can_uav_land' ] = False find_landing_zone_re ( nb_coord , data , shortest_paths_dict , base_neighbours ) hashable_coord def hashable_coord ( coord ) Short summary. Parameters: Name Type Description Default coord type Description of parameter coord . None Returns: Type Description type Description of returned object. View Source def hashable_coord ( coord ) : \" \"\" Short summary. Parameters ---------- coord : type Description of parameter `coord`. Returns ------- type Description of returned object. \"\" \" return str ( coord )","title":"Graph Utils"},{"location":"reference/landing_zone_detection/graph_utils/#module-landing_zone_detectiongraph_utils","text":"None None View Source import numpy as np from landing_zone_detection.label_utils import can_a_person_reach , can_uav_land def do_coord_exist ( coord , matrix_shape ): \"\"\"Check if a 2D coordinate isn't out of bounds. Parameters ---------- coord : ndarray Description of parameter `coord`. matrix_shape : ndarray Description of parameter `matrix_shape`. Returns ------- bool Whether the coordinate exists. \"\"\" return np . bitwise_and ( coord < matrix_shape , coord >= 0 ) . all () def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ): \"\"\"Short summary. Parameters ---------- x1 : type Description of parameter `x1`. y1 : type Description of parameter `y1`. z1 : type Description of parameter `z1`. x2 : type Description of parameter `x2`. y2 : type Description of parameter `y2`. z2 : type Description of parameter `z2`. Returns ------- type Description of returned object. \"\"\" return (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) ** ( 1 / 2 ) def hashable_coord ( coord ): \"\"\"Short summary. Parameters ---------- coord : type Description of parameter `coord`. Returns ------- type Description of returned object. \"\"\" return str ( coord ) def find_landing_zone ( data ): \"\"\"Short summary. Parameters ---------- data : type Description of parameter `data`. Returns ------- type Description of returned object. \"\"\" shortest_paths_dict = {} person_coord_hash = hashable_coord ( data . person_coord ) shortest_paths_dict [ person_coord_hash ] = {} shortest_paths_dict [ person_coord_hash ][ 'path' ] = [ data . person_coord ] shortest_paths_dict [ person_coord_hash ][ 'distance' ] = 0 base_neighbours = np . asarray ([[ 1 , 0 ], [ 0 , 1 ], [ 1 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ], [ - 1 , - 1 ], [ - 1 , 1 ], [ 1 , - 1 ]]) find_landing_zone_re ( data . person_coord , data , shortest_paths_dict , base_neighbours ) del shortest_paths_dict [ person_coord_hash ] for value in shortest_paths_dict . values (): if not value [ 'can_uav_land' ]: continue if 'shortest_distance' not in locals (): shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] continue if shortest_distance > value [ 'distance' ]: shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] if 'shortest_distance' in locals (): return shortest_path , shortest_distance else : return [], - 1 def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ): \"\"\"Short summary. Parameters ---------- current_coord : type Description of parameter `current_coord`. data : type Description of parameter `data`. shortest_paths_dict : type Description of parameter `shortest_paths_dict`. base_neighbours : type Description of parameter `base_neighbours`. Returns ------- type Description of returned object. \"\"\" current_coord_hash = hashable_coord ( current_coord ) current_height = data . height_map [ current_coord [ 0 ]][ current_coord [ 1 ]] current_item = shortest_paths_dict [ current_coord_hash ] neighbour_list = base_neighbours + np . asarray ( current_coord ) for nb_coord in neighbour_list : # ignore coords that do not exist i.e (-1, 99999999) if not do_coord_exist ( nb_coord , data . adj_matrix . shape ): continue nb_label = data . adj_matrix [ nb_coord [ 0 ]][ nb_coord [ 1 ]] # ignore unreachable coords if not can_a_person_reach ( nb_label ): continue nb_coord_hashable = hashable_coord ( nb_coord ) nb_height = data . height_map [ nb_coord [ 0 ]][ nb_coord [ 1 ]] nb_distance = current_item [ 'distance' ] + \\ distance_between_3d_points ( current_coord [ 0 ], current_coord [ 1 ], abs ( current_height ), nb_coord [ 0 ], nb_coord [ 1 ], abs ( nb_height ) ) if nb_coord_hashable not in shortest_paths_dict : shortest_paths_dict [ nb_coord_hashable ] = {} else : if nb_distance > shortest_paths_dict [ nb_coord_hashable ][ 'distance' ]: continue nb_coord_item = shortest_paths_dict [ nb_coord_hashable ] nb_coord_item [ 'distance' ] = nb_distance nb_coord_item [ 'path' ] = shortest_paths_dict [ current_coord_hash ][ 'path' ][:] nb_coord_item [ 'path' ] . append ( nb_coord ) if can_uav_land ( nb_label ): nb_coord_item [ 'can_uav_land' ] = True else : nb_coord_item [ 'can_uav_land' ] = False find_landing_zone_re ( nb_coord , data , shortest_paths_dict , base_neighbours )","title":"Module landing_zone_detection.graph_utils"},{"location":"reference/landing_zone_detection/graph_utils/#functions","text":"","title":"Functions"},{"location":"reference/landing_zone_detection/graph_utils/#distance_between_3d_points","text":"def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ) Short summary. Parameters: Name Type Description Default x1 type Description of parameter x1 . None y1 type Description of parameter y1 . None z1 type Description of parameter z1 . None x2 type Description of parameter x2 . None y2 type Description of parameter y2 . None z2 type Description of parameter z2 . None Returns: Type Description type Description of returned object. View Source def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ) : \" \"\" Short summary. Parameters ---------- x1 : type Description of parameter `x1`. y1 : type Description of parameter `y1`. z1 : type Description of parameter `z1`. x2 : type Description of parameter `x2`. y2 : type Description of parameter `y2`. z2 : type Description of parameter `z2`. Returns ------- type Description of returned object. \"\" \" return (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) ** ( 1 / 2 )","title":"distance_between_3d_points"},{"location":"reference/landing_zone_detection/graph_utils/#do_coord_exist","text":"def do_coord_exist ( coord , matrix_shape ) Check if a 2D coordinate isn't out of bounds. Parameters: Name Type Description Default coord ndarray Description of parameter coord . None matrix_shape ndarray Description of parameter matrix_shape . None Returns: Type Description bool Whether the coordinate exists. View Source def do_coord_exist ( coord , matrix_shape ) : \" \"\" Check if a 2D coordinate isn't out of bounds. Parameters ---------- coord : ndarray Description of parameter `coord`. matrix_shape : ndarray Description of parameter `matrix_shape`. Returns ------- bool Whether the coordinate exists. \"\" \" return np . bitwise_and ( coord < matrix_shape , coord >= 0 ). all ()","title":"do_coord_exist"},{"location":"reference/landing_zone_detection/graph_utils/#find_landing_zone","text":"def find_landing_zone ( data ) Short summary. Parameters: Name Type Description Default data type Description of parameter data . None Returns: Type Description type Description of returned object. View Source def find_landing_zone ( data ) : \"\"\"Short summary. Parameters ---------- data : type Description of parameter `data`. Returns ------- type Description of returned object. \"\"\" shortest_paths_dict = {} person_coord_hash = hashable_coord ( data . person_coord ) shortest_paths_dict [ person_coord_hash ] = {} shortest_paths_dict [ person_coord_hash ][ 'path' ] = [ data.person_coord ] shortest_paths_dict [ person_coord_hash ][ 'distance' ] = 0 base_neighbours = np . asarray ( [ [1, 0 ] , [ 0, 1 ] , [ 1, 1 ] , [ -1, 0 ] , [ 0, -1 ] , [ -1, -1 ] , [ -1, 1 ] , [ 1, -1 ] ] ) find_landing_zone_re ( data . person_coord , data , shortest_paths_dict , base_neighbours ) del shortest_paths_dict [ person_coord_hash ] for value in shortest_paths_dict . values () : if not value [ 'can_uav_land' ] : continue if 'shortest_distance' not in locals () : shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] continue if shortest_distance > value [ 'distance' ] : shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] if 'shortest_distance' in locals () : return shortest_path , shortest_distance else : return [] , - 1","title":"find_landing_zone"},{"location":"reference/landing_zone_detection/graph_utils/#find_landing_zone_re","text":"def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ) Short summary. Parameters: Name Type Description Default current_coord type Description of parameter current_coord . None data type Description of parameter data . None shortest_paths_dict type Description of parameter shortest_paths_dict . None base_neighbours type Description of parameter base_neighbours . None Returns: Type Description type Description of returned object. View Source def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ) : \"\"\"Short summary. Parameters ---------- current_coord : type Description of parameter `current_coord`. data : type Description of parameter `data`. shortest_paths_dict : type Description of parameter `shortest_paths_dict`. base_neighbours : type Description of parameter `base_neighbours`. Returns ------- type Description of returned object. \"\"\" current_coord_hash = hashable_coord ( current_coord ) current_height = data . height_map [ current_coord[0 ] ] [ current_coord[1 ] ] current_item = shortest_paths_dict [ current_coord_hash ] neighbour_list = base_neighbours + np . asarray ( current_coord ) for nb_coord in neighbour_list : # ignore coords that do not exist i . e ( - 1 , 99999999 ) if not do_coord_exist ( nb_coord , data . adj_matrix . shape ) : continue nb_label = data . adj_matrix [ nb_coord[0 ] ] [ nb_coord[1 ] ] # ignore unreachable coords if not can_a_person_reach ( nb_label ) : continue nb_coord_hashable = hashable_coord ( nb_coord ) nb_height = data . height_map [ nb_coord[0 ] ] [ nb_coord[1 ] ] nb_distance = current_item [ 'distance' ] + \\ distance_between_3d_points ( current_coord [ 0 ] , current_coord [ 1 ] , abs ( current_height ), nb_coord [ 0 ] , nb_coord [ 1 ] , abs ( nb_height ) ) if nb_coord_hashable not in shortest_paths_dict : shortest_paths_dict [ nb_coord_hashable ] = {} else : if nb_distance > shortest_paths_dict [ nb_coord_hashable ][ 'distance' ] : continue nb_coord_item = shortest_paths_dict [ nb_coord_hashable ] nb_coord_item [ 'distance' ] = nb_distance nb_coord_item [ 'path' ] = shortest_paths_dict [ current_coord_hash ][ 'path' ][ : ] nb_coord_item [ 'path' ] . append ( nb_coord ) if can_uav_land ( nb_label ) : nb_coord_item [ 'can_uav_land' ] = True else : nb_coord_item [ 'can_uav_land' ] = False find_landing_zone_re ( nb_coord , data , shortest_paths_dict , base_neighbours )","title":"find_landing_zone_re"},{"location":"reference/landing_zone_detection/graph_utils/#hashable_coord","text":"def hashable_coord ( coord ) Short summary. Parameters: Name Type Description Default coord type Description of parameter coord . None Returns: Type Description type Description of returned object. View Source def hashable_coord ( coord ) : \" \"\" Short summary. Parameters ---------- coord : type Description of parameter `coord`. Returns ------- type Description of returned object. \"\" \" return str ( coord )","title":"hashable_coord"},{"location":"reference/landing_zone_detection/label_utils/","text":"Module landing_zone_detection.label_utils None None View Source UAV_CAN_LAND_PERSON_CAN_REACH = 1 UAV_CANNOT_LAND_PERSON_CAN_REACH = 0 UAV_CANNOT_LAND_PERSON_CANNOT_REACH = - 1 def can_uav_land ( label ) : \" \"\" Short summary. Parameters ---------- label : type Description of parameter `label`. Returns ------- type Description of returned object. \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH def can_a_person_reach ( label ) : \" \"\" Short summary. Parameters ---------- label : type Description of parameter `label`. Returns ------- type Description of returned object. \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH or \\ label == UAV_CANNOT_LAND_PERSON_CAN_REACH Variables UAV_CANNOT_LAND_PERSON_CANNOT_REACH UAV_CANNOT_LAND_PERSON_CAN_REACH UAV_CAN_LAND_PERSON_CAN_REACH Functions can_a_person_reach def can_a_person_reach ( label ) Short summary. Parameters: Name Type Description Default label type Description of parameter label . None Returns: Type Description type Description of returned object. View Source def can_a_person_reach ( label ) : \" \"\" Short summary. Parameters ---------- label : type Description of parameter `label`. Returns ------- type Description of returned object. \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH or \\ label == UAV_CANNOT_LAND_PERSON_CAN_REACH can_uav_land def can_uav_land ( label ) Short summary. Parameters: Name Type Description Default label type Description of parameter label . None Returns: Type Description type Description of returned object. View Source def can_uav_land ( label ) : \" \"\" Short summary. Parameters ---------- label : type Description of parameter `label`. Returns ------- type Description of returned object. \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH","title":"Label Utils"},{"location":"reference/landing_zone_detection/label_utils/#module-landing_zone_detectionlabel_utils","text":"None None View Source UAV_CAN_LAND_PERSON_CAN_REACH = 1 UAV_CANNOT_LAND_PERSON_CAN_REACH = 0 UAV_CANNOT_LAND_PERSON_CANNOT_REACH = - 1 def can_uav_land ( label ) : \" \"\" Short summary. Parameters ---------- label : type Description of parameter `label`. Returns ------- type Description of returned object. \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH def can_a_person_reach ( label ) : \" \"\" Short summary. Parameters ---------- label : type Description of parameter `label`. Returns ------- type Description of returned object. \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH or \\ label == UAV_CANNOT_LAND_PERSON_CAN_REACH","title":"Module landing_zone_detection.label_utils"},{"location":"reference/landing_zone_detection/label_utils/#variables","text":"UAV_CANNOT_LAND_PERSON_CANNOT_REACH UAV_CANNOT_LAND_PERSON_CAN_REACH UAV_CAN_LAND_PERSON_CAN_REACH","title":"Variables"},{"location":"reference/landing_zone_detection/label_utils/#functions","text":"","title":"Functions"},{"location":"reference/landing_zone_detection/label_utils/#can_a_person_reach","text":"def can_a_person_reach ( label ) Short summary. Parameters: Name Type Description Default label type Description of parameter label . None Returns: Type Description type Description of returned object. View Source def can_a_person_reach ( label ) : \" \"\" Short summary. Parameters ---------- label : type Description of parameter `label`. Returns ------- type Description of returned object. \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH or \\ label == UAV_CANNOT_LAND_PERSON_CAN_REACH","title":"can_a_person_reach"},{"location":"reference/landing_zone_detection/label_utils/#can_uav_land","text":"def can_uav_land ( label ) Short summary. Parameters: Name Type Description Default label type Description of parameter label . None Returns: Type Description type Description of returned object. View Source def can_uav_land ( label ) : \" \"\" Short summary. Parameters ---------- label : type Description of parameter `label`. Returns ------- type Description of returned object. \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH","title":"can_uav_land"},{"location":"reference/landing_zone_detection/visualization_utils/","text":"Module landing_zone_detection.visualization_utils None None View Source import cv2 import numpy as np import matplotlib.pyplot as plt def item_from_color ( color , col_size = 32 , row_size = 32 ): \"\"\"Short summary. Parameters ---------- color : type Description of parameter `color`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. Returns ------- type Description of returned object. \"\"\" return np . repeat ( [ np . repeat ([ color ], col_size , axis = 0 )], row_size , axis = 0 ) def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ], 0 : [ 168 , 50 , 125 ], - 1 : [ 0 , 0 , 255 ]}, num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Short summary. Parameters ---------- adj_matrix : type Description of parameter `adj_matrix`. value_to_color : type Description of parameter `value_to_color`. num_cols : type Description of parameter `num_cols`. num_rows : type Description of parameter `num_rows`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. img_dtype : type Description of parameter `img_dtype`. Returns ------- type Description of returned object. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) value_to_item = { 1 : item_from_color ( value_to_color [ 1 ]), 0 : item_from_color ( value_to_color [ 0 ]), - 1 : item_from_color ( value_to_color [ - 1 ]), } for i , col in enumerate ( adj_matrix ): x1 = col_size * i x2 = col_size * ( i + 1 ) for j , value in enumerate ( col ): y1 = row_size * j y2 = row_size * ( j + 1 ) img [ x1 : x2 , y1 : y2 , :] = value_to_item [ value ] . copy () return img def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Short summary. Parameters ---------- node_list : type Description of parameter `node_list`. item_color : type Description of parameter `item_color`. num_cols : type Description of parameter `num_cols`. num_rows : type Description of parameter `num_rows`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. img_dtype : type Description of parameter `img_dtype`. Returns ------- type Description of returned object. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) item = item_from_color ( item_color ) for node in node_list : x1 = col_size * node [ 0 ] x2 = col_size * ( node [ 0 ] + 1 ) y1 = row_size * node [ 1 ] y2 = row_size * ( node [ 1 ] + 1 ) img [ x1 : x2 , y1 : y2 , :] = item . copy () return img def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = []): \"\"\"Short summary. Parameters ---------- frame : type Description of parameter `frame`. width : type Description of parameter `width`. height : type Description of parameter `height`. images_to_overlay : type Description of parameter `images_to_overlay`. Returns ------- type Description of returned object. \"\"\" # overlay images on the frame if images_to_overlay : img_to_overlay = images_to_overlay [ 0 ] for img in images_to_overlay [ 1 :]: img_to_overlay += img if images_to_overlay : frame = cv2 . addWeighted ( img_to_overlay , 1.0 , frame , 1.0 , 0.0 ) # resize to desired size with bilinear interpolation frame = cv2 . resize ( frame , ( width , height ), interpolation = cv2 . INTER_LINEAR ) # convert from BGR to RGB for plotting purposes frame = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2RGB ) # plot the resulting frame plt . imshow ( frame ) plt . show () Functions adj_matrix_to_image def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ], 0 : [ 168 , 50 , 125 ], - 1 : [ 0 , 0 , 255 ]}, num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype =< class ' numpy . uint8 '> ) Short summary. Parameters: Name Type Description Default adj_matrix type Description of parameter adj_matrix . None value_to_color type Description of parameter value_to_color . None num_cols type Description of parameter num_cols . None num_rows type Description of parameter num_rows . None col_size type Description of parameter col_size . None row_size type Description of parameter row_size . None img_dtype type Description of parameter img_dtype . None Returns: Type Description type Description of returned object. View Source def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ] , 0 : [ 168 , 50 , 125 ] , - 1 : [ 0 , 0 , 255 ]} , num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ) : \" \"\" Short summary. Parameters ---------- adj_matrix : type Description of parameter `adj_matrix`. value_to_color : type Description of parameter `value_to_color`. num_cols : type Description of parameter `num_cols`. num_rows : type Description of parameter `num_rows`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. img_dtype : type Description of parameter `img_dtype`. Returns ------- type Description of returned object. \"\" \" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) value_to_item = { 1 : item_from_color ( value_to_color [ 1 ] ), 0 : item_from_color ( value_to_color [ 0 ] ), - 1 : item_from_color ( value_to_color [ - 1 ] ), } for i , col in enumerate ( adj_matrix ) : x1 = col_size * i x2 = col_size * ( i + 1 ) for j , value in enumerate ( col ) : y1 = row_size * j y2 = row_size * ( j + 1 ) img [ x1 : x2 , y1 : y2 , : ] = value_to_item [ value ] . copy () return img item_from_color def item_from_color ( color , col_size = 32 , row_size = 32 ) Short summary. Parameters: Name Type Description Default color type Description of parameter color . None col_size type Description of parameter col_size . None row_size type Description of parameter row_size . None Returns: Type Description type Description of returned object. View Source def item_from_color ( color , col_size = 32 , row_size = 32 ) : \" \"\" Short summary. Parameters ---------- color : type Description of parameter `color`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. Returns ------- type Description of returned object. \"\" \" return np . repeat ( [ np . repeat ( [ color ] , col_size , axis = 0 ) ] , row_size , axis = 0 ) node_list_to_image def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype =< class ' numpy . uint8 '> ) Short summary. Parameters: Name Type Description Default node_list type Description of parameter node_list . None item_color type Description of parameter item_color . None num_cols type Description of parameter num_cols . None num_rows type Description of parameter num_rows . None col_size type Description of parameter col_size . None row_size type Description of parameter row_size . None img_dtype type Description of parameter img_dtype . None Returns: Type Description type Description of returned object. View Source def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ] , num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ) : \" \"\" Short summary. Parameters ---------- node_list : type Description of parameter `node_list`. item_color : type Description of parameter `item_color`. num_cols : type Description of parameter `num_cols`. num_rows : type Description of parameter `num_rows`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. img_dtype : type Description of parameter `img_dtype`. Returns ------- type Description of returned object. \"\" \" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) item = item_from_color ( item_color ) for node in node_list : x1 = col_size * node [ 0 ] x2 = col_size * ( node [ 0 ] + 1 ) y1 = row_size * node [ 1 ] y2 = row_size * ( node [ 1 ] + 1 ) img [ x1 : x2 , y1 : y2 , : ] = item . copy () return img plot_frame def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = [] ) Short summary. Parameters: Name Type Description Default frame type Description of parameter frame . None width type Description of parameter width . None height type Description of parameter height . None images_to_overlay type Description of parameter images_to_overlay . None Returns: Type Description type Description of returned object. View Source def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = [] ) : \" \"\" Short summary. Parameters ---------- frame : type Description of parameter `frame`. width : type Description of parameter `width`. height : type Description of parameter `height`. images_to_overlay : type Description of parameter `images_to_overlay`. Returns ------- type Description of returned object. \"\" \" # overlay images on the frame if images_to_overlay : img_to_overlay = images_to_overlay [ 0 ] for img in images_to_overlay [ 1 : ] : img_to_overlay += img if images_to_overlay : frame = cv2 . addWeighted ( img_to_overlay , 1.0 , frame , 1.0 , 0.0 ) # resize to desired size with bilinear interpolation frame = cv2 . resize ( frame , ( width , height ), interpolation = cv2 . INTER_LINEAR ) # convert from BGR to RGB for plotting purposes frame = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2RGB ) # plot the resulting frame plt . imshow ( frame ) plt . show ()","title":"Visualization Utils"},{"location":"reference/landing_zone_detection/visualization_utils/#module-landing_zone_detectionvisualization_utils","text":"None None View Source import cv2 import numpy as np import matplotlib.pyplot as plt def item_from_color ( color , col_size = 32 , row_size = 32 ): \"\"\"Short summary. Parameters ---------- color : type Description of parameter `color`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. Returns ------- type Description of returned object. \"\"\" return np . repeat ( [ np . repeat ([ color ], col_size , axis = 0 )], row_size , axis = 0 ) def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ], 0 : [ 168 , 50 , 125 ], - 1 : [ 0 , 0 , 255 ]}, num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Short summary. Parameters ---------- adj_matrix : type Description of parameter `adj_matrix`. value_to_color : type Description of parameter `value_to_color`. num_cols : type Description of parameter `num_cols`. num_rows : type Description of parameter `num_rows`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. img_dtype : type Description of parameter `img_dtype`. Returns ------- type Description of returned object. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) value_to_item = { 1 : item_from_color ( value_to_color [ 1 ]), 0 : item_from_color ( value_to_color [ 0 ]), - 1 : item_from_color ( value_to_color [ - 1 ]), } for i , col in enumerate ( adj_matrix ): x1 = col_size * i x2 = col_size * ( i + 1 ) for j , value in enumerate ( col ): y1 = row_size * j y2 = row_size * ( j + 1 ) img [ x1 : x2 , y1 : y2 , :] = value_to_item [ value ] . copy () return img def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Short summary. Parameters ---------- node_list : type Description of parameter `node_list`. item_color : type Description of parameter `item_color`. num_cols : type Description of parameter `num_cols`. num_rows : type Description of parameter `num_rows`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. img_dtype : type Description of parameter `img_dtype`. Returns ------- type Description of returned object. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) item = item_from_color ( item_color ) for node in node_list : x1 = col_size * node [ 0 ] x2 = col_size * ( node [ 0 ] + 1 ) y1 = row_size * node [ 1 ] y2 = row_size * ( node [ 1 ] + 1 ) img [ x1 : x2 , y1 : y2 , :] = item . copy () return img def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = []): \"\"\"Short summary. Parameters ---------- frame : type Description of parameter `frame`. width : type Description of parameter `width`. height : type Description of parameter `height`. images_to_overlay : type Description of parameter `images_to_overlay`. Returns ------- type Description of returned object. \"\"\" # overlay images on the frame if images_to_overlay : img_to_overlay = images_to_overlay [ 0 ] for img in images_to_overlay [ 1 :]: img_to_overlay += img if images_to_overlay : frame = cv2 . addWeighted ( img_to_overlay , 1.0 , frame , 1.0 , 0.0 ) # resize to desired size with bilinear interpolation frame = cv2 . resize ( frame , ( width , height ), interpolation = cv2 . INTER_LINEAR ) # convert from BGR to RGB for plotting purposes frame = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2RGB ) # plot the resulting frame plt . imshow ( frame ) plt . show ()","title":"Module landing_zone_detection.visualization_utils"},{"location":"reference/landing_zone_detection/visualization_utils/#functions","text":"","title":"Functions"},{"location":"reference/landing_zone_detection/visualization_utils/#adj_matrix_to_image","text":"def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ], 0 : [ 168 , 50 , 125 ], - 1 : [ 0 , 0 , 255 ]}, num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype =< class ' numpy . uint8 '> ) Short summary. Parameters: Name Type Description Default adj_matrix type Description of parameter adj_matrix . None value_to_color type Description of parameter value_to_color . None num_cols type Description of parameter num_cols . None num_rows type Description of parameter num_rows . None col_size type Description of parameter col_size . None row_size type Description of parameter row_size . None img_dtype type Description of parameter img_dtype . None Returns: Type Description type Description of returned object. View Source def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ] , 0 : [ 168 , 50 , 125 ] , - 1 : [ 0 , 0 , 255 ]} , num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ) : \" \"\" Short summary. Parameters ---------- adj_matrix : type Description of parameter `adj_matrix`. value_to_color : type Description of parameter `value_to_color`. num_cols : type Description of parameter `num_cols`. num_rows : type Description of parameter `num_rows`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. img_dtype : type Description of parameter `img_dtype`. Returns ------- type Description of returned object. \"\" \" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) value_to_item = { 1 : item_from_color ( value_to_color [ 1 ] ), 0 : item_from_color ( value_to_color [ 0 ] ), - 1 : item_from_color ( value_to_color [ - 1 ] ), } for i , col in enumerate ( adj_matrix ) : x1 = col_size * i x2 = col_size * ( i + 1 ) for j , value in enumerate ( col ) : y1 = row_size * j y2 = row_size * ( j + 1 ) img [ x1 : x2 , y1 : y2 , : ] = value_to_item [ value ] . copy () return img","title":"adj_matrix_to_image"},{"location":"reference/landing_zone_detection/visualization_utils/#item_from_color","text":"def item_from_color ( color , col_size = 32 , row_size = 32 ) Short summary. Parameters: Name Type Description Default color type Description of parameter color . None col_size type Description of parameter col_size . None row_size type Description of parameter row_size . None Returns: Type Description type Description of returned object. View Source def item_from_color ( color , col_size = 32 , row_size = 32 ) : \" \"\" Short summary. Parameters ---------- color : type Description of parameter `color`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. Returns ------- type Description of returned object. \"\" \" return np . repeat ( [ np . repeat ( [ color ] , col_size , axis = 0 ) ] , row_size , axis = 0 )","title":"item_from_color"},{"location":"reference/landing_zone_detection/visualization_utils/#node_list_to_image","text":"def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype =< class ' numpy . uint8 '> ) Short summary. Parameters: Name Type Description Default node_list type Description of parameter node_list . None item_color type Description of parameter item_color . None num_cols type Description of parameter num_cols . None num_rows type Description of parameter num_rows . None col_size type Description of parameter col_size . None row_size type Description of parameter row_size . None img_dtype type Description of parameter img_dtype . None Returns: Type Description type Description of returned object. View Source def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ] , num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ) : \" \"\" Short summary. Parameters ---------- node_list : type Description of parameter `node_list`. item_color : type Description of parameter `item_color`. num_cols : type Description of parameter `num_cols`. num_rows : type Description of parameter `num_rows`. col_size : type Description of parameter `col_size`. row_size : type Description of parameter `row_size`. img_dtype : type Description of parameter `img_dtype`. Returns ------- type Description of returned object. \"\" \" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) item = item_from_color ( item_color ) for node in node_list : x1 = col_size * node [ 0 ] x2 = col_size * ( node [ 0 ] + 1 ) y1 = row_size * node [ 1 ] y2 = row_size * ( node [ 1 ] + 1 ) img [ x1 : x2 , y1 : y2 , : ] = item . copy () return img","title":"node_list_to_image"},{"location":"reference/landing_zone_detection/visualization_utils/#plot_frame","text":"def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = [] ) Short summary. Parameters: Name Type Description Default frame type Description of parameter frame . None width type Description of parameter width . None height type Description of parameter height . None images_to_overlay type Description of parameter images_to_overlay . None Returns: Type Description type Description of returned object. View Source def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = [] ) : \" \"\" Short summary. Parameters ---------- frame : type Description of parameter `frame`. width : type Description of parameter `width`. height : type Description of parameter `height`. images_to_overlay : type Description of parameter `images_to_overlay`. Returns ------- type Description of returned object. \"\" \" # overlay images on the frame if images_to_overlay : img_to_overlay = images_to_overlay [ 0 ] for img in images_to_overlay [ 1 : ] : img_to_overlay += img if images_to_overlay : frame = cv2 . addWeighted ( img_to_overlay , 1.0 , frame , 1.0 , 0.0 ) # resize to desired size with bilinear interpolation frame = cv2 . resize ( frame , ( width , height ), interpolation = cv2 . INTER_LINEAR ) # convert from BGR to RGB for plotting purposes frame = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2RGB ) # plot the resulting frame plt . imshow ( frame ) plt . show ()","title":"plot_frame"}]}