{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Closest Landing Zone This algorithm finds the closest and reachable safe landing zone next to the human who's waiting for the autonomous UAV. List Number : X Discipline Subject : Graphs II Students Number Student 17/0146251 Jo\u00e3o Lucas Zarbi\u00e9lli 19/0046945 Leonardo Michalski Miranda About We generated some mock test data from Pokemon Emerald. These are the rules for it: The UAV can only land in the green area with low grass. A human can move between areas with tall grass and low grass, but not trees. The closest path is not always the most obvious as there are unevenness between the terrains, so the algorithm must be able to find the shortest path taking it into account. There might also be a landing zone that is so high that it is unreachable by a human, like the roof of a house. So even if it's the closest place the UAV cannot land there. App Gif Video (pt-br, download link ) How to run Language : Python. Frameworks : OpenCV; Jupyter Voil\u00e0; BinderHub. Access the app or the notebook with the BinderHub server. How to use The app generate a random image for each iteration. Everytime you click the update button, a new random image is generated and the algorithm gets executed. References Jupyter et al., \"Binder 2.0 - Reproducible, Interactive, Sharable Environments for Science at Scale.\" Proceedings of the 17th Python in Science Conference. 2018. doi://10.25080/Majora-4af1f417-011","title":"Home"},{"location":"#closest-landing-zone","text":"This algorithm finds the closest and reachable safe landing zone next to the human who's waiting for the autonomous UAV. List Number : X Discipline Subject : Graphs II","title":"Closest Landing Zone"},{"location":"#students","text":"Number Student 17/0146251 Jo\u00e3o Lucas Zarbi\u00e9lli 19/0046945 Leonardo Michalski Miranda","title":"Students"},{"location":"#about","text":"We generated some mock test data from Pokemon Emerald. These are the rules for it: The UAV can only land in the green area with low grass. A human can move between areas with tall grass and low grass, but not trees. The closest path is not always the most obvious as there are unevenness between the terrains, so the algorithm must be able to find the shortest path taking it into account. There might also be a landing zone that is so high that it is unreachable by a human, like the roof of a house. So even if it's the closest place the UAV cannot land there.","title":"About"},{"location":"#app-gif","text":"","title":"App Gif"},{"location":"#video-pt-br-download-link","text":"","title":"Video (pt-br, download link)"},{"location":"#how-to-run","text":"Language : Python. Frameworks : OpenCV; Jupyter Voil\u00e0; BinderHub. Access the app or the notebook with the BinderHub server.","title":"How to run"},{"location":"#how-to-use","text":"The app generate a random image for each iteration. Everytime you click the update button, a new random image is generated and the algorithm gets executed.","title":"How to use"},{"location":"#references","text":"Jupyter et al., \"Binder 2.0 - Reproducible, Interactive, Sharable Environments for Science at Scale.\" Proceedings of the 17th Python in Science Conference. 2018. doi://10.25080/Majora-4af1f417-011","title":"References"},{"location":"reference/landing_zone_detection/","text":"Module landing_zone_detection None None Sub-modules landing_zone_detection.data landing_zone_detection.graph_utils landing_zone_detection.label_utils landing_zone_detection.visualization_utils","title":"Index"},{"location":"reference/landing_zone_detection/#module-landing_zone_detection","text":"None None","title":"Module landing_zone_detection"},{"location":"reference/landing_zone_detection/#sub-modules","text":"landing_zone_detection.data landing_zone_detection.graph_utils landing_zone_detection.label_utils landing_zone_detection.visualization_utils","title":"Sub-modules"},{"location":"reference/landing_zone_detection/data/","text":"Module landing_zone_detection.data None None View Source import numpy as np import cv2 from landing_zone_detection import label_utils import os class AerialImageData ( object ): \"\"\"Aerial image and its surrounding data. Parameters ---------- frame : numpy.ndarray Frame (image) taken by the flying UAV. adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. height_map : numpy.ndarray Depth estimation of the frame. Same shape as the adj_matrix. person_coord : list (x, y) coordinate of a person in the adj_matrix. This is the person who's supposed to receive the UAV. \"\"\" def __init__ ( self , frame = None , adj_matrix = None , height_map = None , person_coord = None ): self . frame = frame self . adj_matrix = adj_matrix self . height_map = height_map self . person_coord = person_coord # UTILITIES TO GENERATE RANDOM DATA MOCK_DATA_PATH = 'mock_data' TERRAIN_OPTIONS_IMAGES = [ os . path . join ( MOCK_DATA_PATH , 'grass.png' ), os . path . join ( MOCK_DATA_PATH , 'grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'tree.png' ), os . path . join ( MOCK_DATA_PATH , 'tree_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'tree_pincushion.png' ), ] PERSON_OPTIONS_IMAGES = [ os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass_pincushion.png' ), ] TERRAIN_OPTIONS_LABELS = [ label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass_barrel label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree_barrel label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree_pincushion ] PERSON_OPTIONS_LABELS = [ label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass_pincushion ] TERRAIN_OPTIONS_HEIGHTS = [ 0 , # grass 0.8 , # grass_barrel - 1.2 , # grass_pincushion 0 , # tall_grass 0.8 , # tall_grass_barrel - 1.2 , # tall_grass_pincushion 0 , # tree 0.8 , # tree_barrel - 1.2 , # tree_pincushion ] PERSON_OPTIONS_HEIGHTS = [ 0 , # person_in_tall_grass 0.8 , # person_in_tall_grass_barrel - 1.2 , # person_in_tall_grass_pincushion 0 , # person_on_grass 0.8 , # person_on_grass_barrel - 1.2 , # person_on_grass_pincushion ] class RandomAerialImageDataGenerator ( object ): \"\"\"Class to generate random AerialImageData object using the given terrain and person options. Parameters ---------- width : int Image width. height : int Image height. channels : int Number of channels in the image. dtype : np.uint8 Data type of the frame. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. terrain_options_images : list Each item of the image can randomly assume one of this images. terrain_options_labels : list Labels of each option in terrain_options_images. terrain_options_heights : list Estimated depth (height from the drone to the ground) of each option in terrain_options_images. person_options_images : list Until now, only one random item of the image can assume one of this images. In other words: only one person per image. person_options_labels : list Labels of each person_options in person_options_images. person_options_heights : list Estimated depth (height from the drone to the ground) of each option in person_options_images. Attributes ---------- num_cols : type Number of columns in each adj_matrix (or height_map) item. num_rows : type Number of rows in each adj_matrix (or height_map) item. \"\"\" def __init__ ( self , width = 224 , height = 224 , channels = 3 , dtype = np . uint8 , col_size = 32 , row_size = 32 , terrain_options_images = TERRAIN_OPTIONS_IMAGES , terrain_options_labels = TERRAIN_OPTIONS_LABELS , terrain_options_heights = TERRAIN_OPTIONS_HEIGHTS , person_options_images = PERSON_OPTIONS_IMAGES , person_options_labels = PERSON_OPTIONS_LABELS , person_options_heights = PERSON_OPTIONS_HEIGHTS ): self . width = width self . height = height self . channels = channels self . dtype = dtype self . col_size = col_size self . row_size = row_size self . terrain_options_images = terrain_options_images self . terrain_options_labels = terrain_options_labels self . terrain_options_heights = terrain_options_heights self . person_options_images = person_options_images self . person_options_labels = person_options_labels self . person_options_heights = person_options_heights self . num_cols = self . width // self . col_size self . num_rows = self . height // self . row_size self . terrain_options_images = self . load_img_items ( self . terrain_options_images ) self . person_options_images = self . load_img_items ( self . person_options_images ) def __read_img_item ( self , filename , ** kwargs ): \"\"\"Read an image item from filename. Parameters ---------- filename : str File path. **kwargs : dict **kwargs. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" return cv2 . imread ( filename , ** kwargs ) def __resize_img_item ( self , img_item , resize_method = cv2 . INTER_LINEAR , ** kwargs ): \"\"\"Resize an image item. Parameters ---------- img_item : numpy.ndarray 2D matrix representing an image. resize_method : int Type of the resize method i.e cv2.INTER_LINEAR. **kwargs : dict **kwargs Returns ------- numpy.ndarray Resized image. \"\"\" return cv2 . resize ( src = img_item , dsize = ( self . col_size , self . row_size ), interpolation = resize_method , ** kwargs ) def load_img_items ( self , img_items ): \"\"\"Read and transform a list of image items. Parameters ---------- img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items def generate ( self ): \"\"\"Generates a random AerialImageData object using the given terrain and person options. Returns ------- AerialImageData Aerial image and its surrounding data. \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . float32 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . float32 , ) ) # populate with the terrain options for i in range ( self . num_cols ): x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ): y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i , j ] return data Variables MOCK_DATA_PATH PERSON_OPTIONS_HEIGHTS PERSON_OPTIONS_IMAGES PERSON_OPTIONS_LABELS TERRAIN_OPTIONS_HEIGHTS TERRAIN_OPTIONS_IMAGES TERRAIN_OPTIONS_LABELS Classes AerialImageData class AerialImageData ( frame = None , adj_matrix = None , height_map = None , person_coord = None ) Attributes Name Type Description Default frame numpy.ndarray Frame (image) taken by the flying UAV. None adj_matrix numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. None height_map numpy.ndarray Depth estimation of the frame. Same shape as the adj_matrix. None person_coord list (x, y) coordinate of a person in the adj_matrix. This is the person who's supposed to receive the UAV. None View Source class AerialImageData ( object ): \"\"\"Aerial image and its surrounding data. Parameters ---------- frame : numpy.ndarray Frame (image) taken by the flying UAV. adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. height_map : numpy.ndarray Depth estimation of the frame. Same shape as the adj_matrix. person_coord : list (x, y) coordinate of a person in the adj_matrix. This is the person who's supposed to receive the UAV. \"\"\" def __init__ ( self , frame = None , adj_matrix = None , height_map = None , person_coord = None ): self . frame = frame self . adj_matrix = adj_matrix self . height_map = height_map self . person_coord = person_coord RandomAerialImageDataGenerator class RandomAerialImageDataGenerator ( width = 224 , height = 224 , channels = 3 , dtype =< class ' numpy . uint8 '>, col_size = 32 , row_size = 32 , terrain_options_images = [ 'mock_data/grass.png' , 'mock_data/grass_barrel.png' , 'mock_data/grass_pincushion.png' , 'mock_data/tall_grass.png' , 'mock_data/tall_grass_barrel.png' , 'mock_data/tall_grass_pincushion.png' , 'mock_data/tree.png' , 'mock_data/tree_barrel.png' , 'mock_data/tree_pincushion.png' ], terrain_options_labels = [ 1 , 1 , 1 , 0 , 0 , 0 , - 1 , - 1 , - 1 ], terrain_options_heights = [ 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 ], person_options_images = [ 'mock_data/person_in_tall_grass.png' , 'mock_data/person_in_tall_grass_barrel.png' , 'mock_data/person_in_tall_grass_pincushion.png' , 'mock_data/person_on_grass.png' , 'mock_data/person_on_grass_barrel.png' , 'mock_data/person_on_grass_pincushion.png' ], person_options_labels = [ 0 , 0 , 0 , 0 , 0 , 0 ], person_options_heights = [ 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 ] ) Attributes Name Type Description Default width int Image width. None height int Image height. None channels int Number of channels in the image. None dtype np.uint8 Data type of the frame. None col_size int Width of each adj_matrix (or height_map) item. None row_size int Height of each adj_matrix (or height_map) item. None terrain_options_images list Each item of the image can randomly assume one of this images. None terrain_options_labels list Labels of each option in terrain_options_images. None terrain_options_heights list Estimated depth (height from the drone to the ground) of each option in terrain_options_images. None person_options_images list Until now, only one random item of the image can assume one of this images. In other words: only one person per image. None person_options_labels list Labels of each person_options in person_options_images. None person_options_heights list Estimated depth (height from the drone to the ground) of each option in person_options_images. None num_cols type Number of columns in each adj_matrix (or height_map) item. None num_rows type Number of rows in each adj_matrix (or height_map) item. None View Source class RandomAerialImageDataGenerator ( object ): \"\"\"Class to generate random AerialImageData object using the given terrain and person options. Parameters ---------- width : int Image width. height : int Image height. channels : int Number of channels in the image. dtype : np.uint8 Data type of the frame. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. terrain_options_images : list Each item of the image can randomly assume one of this images. terrain_options_labels : list Labels of each option in terrain_options_images. terrain_options_heights : list Estimated depth (height from the drone to the ground) of each option in terrain_options_images. person_options_images : list Until now, only one random item of the image can assume one of this images. In other words: only one person per image. person_options_labels : list Labels of each person_options in person_options_images. person_options_heights : list Estimated depth (height from the drone to the ground) of each option in person_options_images. Attributes ---------- num_cols : type Number of columns in each adj_matrix (or height_map) item. num_rows : type Number of rows in each adj_matrix (or height_map) item. \"\"\" def __init__ ( self , width = 224 , height = 224 , channels = 3 , dtype = np . uint8 , col_size = 32 , row_size = 32 , terrain_options_images = TERRAIN_OPTIONS_IMAGES , terrain_options_labels = TERRAIN_OPTIONS_LABELS , terrain_options_heights = TERRAIN_OPTIONS_HEIGHTS , person_options_images = PERSON_OPTIONS_IMAGES , person_options_labels = PERSON_OPTIONS_LABELS , person_options_heights = PERSON_OPTIONS_HEIGHTS ): self . width = width self . height = height self . channels = channels self . dtype = dtype self . col_size = col_size self . row_size = row_size self . terrain_options_images = terrain_options_images self . terrain_options_labels = terrain_options_labels self . terrain_options_heights = terrain_options_heights self . person_options_images = person_options_images self . person_options_labels = person_options_labels self . person_options_heights = person_options_heights self . num_cols = self . width // self . col_size self . num_rows = self . height // self . row_size self . terrain_options_images = self . load_img_items ( self . terrain_options_images ) self . person_options_images = self . load_img_items ( self . person_options_images ) def __read_img_item ( self , filename , ** kwargs ): \"\"\"Read an image item from filename. Parameters ---------- filename : str File path. **kwargs : dict **kwargs. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" return cv2 . imread ( filename , ** kwargs ) def __resize_img_item ( self , img_item , resize_method = cv2 . INTER_LINEAR , ** kwargs ): \"\"\"Resize an image item. Parameters ---------- img_item : numpy.ndarray 2D matrix representing an image. resize_method : int Type of the resize method i.e cv2.INTER_LINEAR. **kwargs : dict **kwargs Returns ------- numpy.ndarray Resized image. \"\"\" return cv2 . resize ( src = img_item , dsize = ( self . col_size , self . row_size ), interpolation = resize_method , ** kwargs ) def load_img_items ( self , img_items ): \"\"\"Read and transform a list of image items. Parameters ---------- img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items def generate ( self ): \"\"\"Generates a random AerialImageData object using the given terrain and person options. Returns ------- AerialImageData Aerial image and its surrounding data. \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . float32 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . float32 , ) ) # populate with the terrain options for i in range ( self . num_cols ): x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ): y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i , j ] return data Methods generate def generate ( self ) Generates a random AerialImageData object using the given terrain and person options. Returns: Type Description AerialImageData Aerial image and its surrounding data. View Source def generate ( self ) : \"\"\"Generates a random AerialImageData object using the given terrain and person options. Returns ------- AerialImageData Aerial image and its surrounding data. \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . float32 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . float32 , ) ) # populate with the terrain options for i in range ( self . num_cols ) : x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ) : y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1:x2, y1:y2, : ] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1:x2, y1:y2, : ] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i, j ] return data load_img_items def load_img_items ( self , img_items ) Read and transform a list of image items. Parameters: Name Type Description Default img_items list List of paths, or list of numpy.ndarrays. None Returns: Type Description list List of the transformed images. View Source def load_img_items ( self , img_items ): \"\"\"Read and transform a list of image items. Parameters ---------- img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items","title":"Data"},{"location":"reference/landing_zone_detection/data/#module-landing_zone_detectiondata","text":"None None View Source import numpy as np import cv2 from landing_zone_detection import label_utils import os class AerialImageData ( object ): \"\"\"Aerial image and its surrounding data. Parameters ---------- frame : numpy.ndarray Frame (image) taken by the flying UAV. adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. height_map : numpy.ndarray Depth estimation of the frame. Same shape as the adj_matrix. person_coord : list (x, y) coordinate of a person in the adj_matrix. This is the person who's supposed to receive the UAV. \"\"\" def __init__ ( self , frame = None , adj_matrix = None , height_map = None , person_coord = None ): self . frame = frame self . adj_matrix = adj_matrix self . height_map = height_map self . person_coord = person_coord # UTILITIES TO GENERATE RANDOM DATA MOCK_DATA_PATH = 'mock_data' TERRAIN_OPTIONS_IMAGES = [ os . path . join ( MOCK_DATA_PATH , 'grass.png' ), os . path . join ( MOCK_DATA_PATH , 'grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'tree.png' ), os . path . join ( MOCK_DATA_PATH , 'tree_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'tree_pincushion.png' ), ] PERSON_OPTIONS_IMAGES = [ os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass_pincushion.png' ), ] TERRAIN_OPTIONS_LABELS = [ label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass_barrel label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree_barrel label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree_pincushion ] PERSON_OPTIONS_LABELS = [ label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass_pincushion ] TERRAIN_OPTIONS_HEIGHTS = [ 0 , # grass 0.8 , # grass_barrel - 1.2 , # grass_pincushion 0 , # tall_grass 0.8 , # tall_grass_barrel - 1.2 , # tall_grass_pincushion 0 , # tree 0.8 , # tree_barrel - 1.2 , # tree_pincushion ] PERSON_OPTIONS_HEIGHTS = [ 0 , # person_in_tall_grass 0.8 , # person_in_tall_grass_barrel - 1.2 , # person_in_tall_grass_pincushion 0 , # person_on_grass 0.8 , # person_on_grass_barrel - 1.2 , # person_on_grass_pincushion ] class RandomAerialImageDataGenerator ( object ): \"\"\"Class to generate random AerialImageData object using the given terrain and person options. Parameters ---------- width : int Image width. height : int Image height. channels : int Number of channels in the image. dtype : np.uint8 Data type of the frame. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. terrain_options_images : list Each item of the image can randomly assume one of this images. terrain_options_labels : list Labels of each option in terrain_options_images. terrain_options_heights : list Estimated depth (height from the drone to the ground) of each option in terrain_options_images. person_options_images : list Until now, only one random item of the image can assume one of this images. In other words: only one person per image. person_options_labels : list Labels of each person_options in person_options_images. person_options_heights : list Estimated depth (height from the drone to the ground) of each option in person_options_images. Attributes ---------- num_cols : type Number of columns in each adj_matrix (or height_map) item. num_rows : type Number of rows in each adj_matrix (or height_map) item. \"\"\" def __init__ ( self , width = 224 , height = 224 , channels = 3 , dtype = np . uint8 , col_size = 32 , row_size = 32 , terrain_options_images = TERRAIN_OPTIONS_IMAGES , terrain_options_labels = TERRAIN_OPTIONS_LABELS , terrain_options_heights = TERRAIN_OPTIONS_HEIGHTS , person_options_images = PERSON_OPTIONS_IMAGES , person_options_labels = PERSON_OPTIONS_LABELS , person_options_heights = PERSON_OPTIONS_HEIGHTS ): self . width = width self . height = height self . channels = channels self . dtype = dtype self . col_size = col_size self . row_size = row_size self . terrain_options_images = terrain_options_images self . terrain_options_labels = terrain_options_labels self . terrain_options_heights = terrain_options_heights self . person_options_images = person_options_images self . person_options_labels = person_options_labels self . person_options_heights = person_options_heights self . num_cols = self . width // self . col_size self . num_rows = self . height // self . row_size self . terrain_options_images = self . load_img_items ( self . terrain_options_images ) self . person_options_images = self . load_img_items ( self . person_options_images ) def __read_img_item ( self , filename , ** kwargs ): \"\"\"Read an image item from filename. Parameters ---------- filename : str File path. **kwargs : dict **kwargs. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" return cv2 . imread ( filename , ** kwargs ) def __resize_img_item ( self , img_item , resize_method = cv2 . INTER_LINEAR , ** kwargs ): \"\"\"Resize an image item. Parameters ---------- img_item : numpy.ndarray 2D matrix representing an image. resize_method : int Type of the resize method i.e cv2.INTER_LINEAR. **kwargs : dict **kwargs Returns ------- numpy.ndarray Resized image. \"\"\" return cv2 . resize ( src = img_item , dsize = ( self . col_size , self . row_size ), interpolation = resize_method , ** kwargs ) def load_img_items ( self , img_items ): \"\"\"Read and transform a list of image items. Parameters ---------- img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items def generate ( self ): \"\"\"Generates a random AerialImageData object using the given terrain and person options. Returns ------- AerialImageData Aerial image and its surrounding data. \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . float32 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . float32 , ) ) # populate with the terrain options for i in range ( self . num_cols ): x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ): y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i , j ] return data","title":"Module landing_zone_detection.data"},{"location":"reference/landing_zone_detection/data/#variables","text":"MOCK_DATA_PATH PERSON_OPTIONS_HEIGHTS PERSON_OPTIONS_IMAGES PERSON_OPTIONS_LABELS TERRAIN_OPTIONS_HEIGHTS TERRAIN_OPTIONS_IMAGES TERRAIN_OPTIONS_LABELS","title":"Variables"},{"location":"reference/landing_zone_detection/data/#classes","text":"","title":"Classes"},{"location":"reference/landing_zone_detection/data/#aerialimagedata","text":"class AerialImageData ( frame = None , adj_matrix = None , height_map = None , person_coord = None )","title":"AerialImageData"},{"location":"reference/landing_zone_detection/data/#attributes","text":"Name Type Description Default frame numpy.ndarray Frame (image) taken by the flying UAV. None adj_matrix numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. None height_map numpy.ndarray Depth estimation of the frame. Same shape as the adj_matrix. None person_coord list (x, y) coordinate of a person in the adj_matrix. This is the person who's supposed to receive the UAV. None View Source class AerialImageData ( object ): \"\"\"Aerial image and its surrounding data. Parameters ---------- frame : numpy.ndarray Frame (image) taken by the flying UAV. adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. height_map : numpy.ndarray Depth estimation of the frame. Same shape as the adj_matrix. person_coord : list (x, y) coordinate of a person in the adj_matrix. This is the person who's supposed to receive the UAV. \"\"\" def __init__ ( self , frame = None , adj_matrix = None , height_map = None , person_coord = None ): self . frame = frame self . adj_matrix = adj_matrix self . height_map = height_map self . person_coord = person_coord","title":"Attributes"},{"location":"reference/landing_zone_detection/data/#randomaerialimagedatagenerator","text":"class RandomAerialImageDataGenerator ( width = 224 , height = 224 , channels = 3 , dtype =< class ' numpy . uint8 '>, col_size = 32 , row_size = 32 , terrain_options_images = [ 'mock_data/grass.png' , 'mock_data/grass_barrel.png' , 'mock_data/grass_pincushion.png' , 'mock_data/tall_grass.png' , 'mock_data/tall_grass_barrel.png' , 'mock_data/tall_grass_pincushion.png' , 'mock_data/tree.png' , 'mock_data/tree_barrel.png' , 'mock_data/tree_pincushion.png' ], terrain_options_labels = [ 1 , 1 , 1 , 0 , 0 , 0 , - 1 , - 1 , - 1 ], terrain_options_heights = [ 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 ], person_options_images = [ 'mock_data/person_in_tall_grass.png' , 'mock_data/person_in_tall_grass_barrel.png' , 'mock_data/person_in_tall_grass_pincushion.png' , 'mock_data/person_on_grass.png' , 'mock_data/person_on_grass_barrel.png' , 'mock_data/person_on_grass_pincushion.png' ], person_options_labels = [ 0 , 0 , 0 , 0 , 0 , 0 ], person_options_heights = [ 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 ] )","title":"RandomAerialImageDataGenerator"},{"location":"reference/landing_zone_detection/data/#attributes_1","text":"Name Type Description Default width int Image width. None height int Image height. None channels int Number of channels in the image. None dtype np.uint8 Data type of the frame. None col_size int Width of each adj_matrix (or height_map) item. None row_size int Height of each adj_matrix (or height_map) item. None terrain_options_images list Each item of the image can randomly assume one of this images. None terrain_options_labels list Labels of each option in terrain_options_images. None terrain_options_heights list Estimated depth (height from the drone to the ground) of each option in terrain_options_images. None person_options_images list Until now, only one random item of the image can assume one of this images. In other words: only one person per image. None person_options_labels list Labels of each person_options in person_options_images. None person_options_heights list Estimated depth (height from the drone to the ground) of each option in person_options_images. None num_cols type Number of columns in each adj_matrix (or height_map) item. None num_rows type Number of rows in each adj_matrix (or height_map) item. None View Source class RandomAerialImageDataGenerator ( object ): \"\"\"Class to generate random AerialImageData object using the given terrain and person options. Parameters ---------- width : int Image width. height : int Image height. channels : int Number of channels in the image. dtype : np.uint8 Data type of the frame. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. terrain_options_images : list Each item of the image can randomly assume one of this images. terrain_options_labels : list Labels of each option in terrain_options_images. terrain_options_heights : list Estimated depth (height from the drone to the ground) of each option in terrain_options_images. person_options_images : list Until now, only one random item of the image can assume one of this images. In other words: only one person per image. person_options_labels : list Labels of each person_options in person_options_images. person_options_heights : list Estimated depth (height from the drone to the ground) of each option in person_options_images. Attributes ---------- num_cols : type Number of columns in each adj_matrix (or height_map) item. num_rows : type Number of rows in each adj_matrix (or height_map) item. \"\"\" def __init__ ( self , width = 224 , height = 224 , channels = 3 , dtype = np . uint8 , col_size = 32 , row_size = 32 , terrain_options_images = TERRAIN_OPTIONS_IMAGES , terrain_options_labels = TERRAIN_OPTIONS_LABELS , terrain_options_heights = TERRAIN_OPTIONS_HEIGHTS , person_options_images = PERSON_OPTIONS_IMAGES , person_options_labels = PERSON_OPTIONS_LABELS , person_options_heights = PERSON_OPTIONS_HEIGHTS ): self . width = width self . height = height self . channels = channels self . dtype = dtype self . col_size = col_size self . row_size = row_size self . terrain_options_images = terrain_options_images self . terrain_options_labels = terrain_options_labels self . terrain_options_heights = terrain_options_heights self . person_options_images = person_options_images self . person_options_labels = person_options_labels self . person_options_heights = person_options_heights self . num_cols = self . width // self . col_size self . num_rows = self . height // self . row_size self . terrain_options_images = self . load_img_items ( self . terrain_options_images ) self . person_options_images = self . load_img_items ( self . person_options_images ) def __read_img_item ( self , filename , ** kwargs ): \"\"\"Read an image item from filename. Parameters ---------- filename : str File path. **kwargs : dict **kwargs. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" return cv2 . imread ( filename , ** kwargs ) def __resize_img_item ( self , img_item , resize_method = cv2 . INTER_LINEAR , ** kwargs ): \"\"\"Resize an image item. Parameters ---------- img_item : numpy.ndarray 2D matrix representing an image. resize_method : int Type of the resize method i.e cv2.INTER_LINEAR. **kwargs : dict **kwargs Returns ------- numpy.ndarray Resized image. \"\"\" return cv2 . resize ( src = img_item , dsize = ( self . col_size , self . row_size ), interpolation = resize_method , ** kwargs ) def load_img_items ( self , img_items ): \"\"\"Read and transform a list of image items. Parameters ---------- img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items def generate ( self ): \"\"\"Generates a random AerialImageData object using the given terrain and person options. Returns ------- AerialImageData Aerial image and its surrounding data. \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . float32 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . float32 , ) ) # populate with the terrain options for i in range ( self . num_cols ): x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ): y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i , j ] return data","title":"Attributes"},{"location":"reference/landing_zone_detection/data/#methods","text":"","title":"Methods"},{"location":"reference/landing_zone_detection/data/#generate","text":"def generate ( self ) Generates a random AerialImageData object using the given terrain and person options. Returns: Type Description AerialImageData Aerial image and its surrounding data. View Source def generate ( self ) : \"\"\"Generates a random AerialImageData object using the given terrain and person options. Returns ------- AerialImageData Aerial image and its surrounding data. \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . float32 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . float32 , ) ) # populate with the terrain options for i in range ( self . num_cols ) : x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ) : y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1:x2, y1:y2, : ] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1:x2, y1:y2, : ] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i, j ] return data","title":"generate"},{"location":"reference/landing_zone_detection/data/#load_img_items","text":"def load_img_items ( self , img_items ) Read and transform a list of image items. Parameters: Name Type Description Default img_items list List of paths, or list of numpy.ndarrays. None Returns: Type Description list List of the transformed images. View Source def load_img_items ( self , img_items ): \"\"\"Read and transform a list of image items. Parameters ---------- img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items","title":"load_img_items"},{"location":"reference/landing_zone_detection/graph_utils/","text":"Module landing_zone_detection.graph_utils None None View Source import numpy as np from landing_zone_detection.label_utils import can_a_person_reach , can_uav_land def do_coord_exist ( coord , matrix_shape ): \"\"\"Check if a 2D coordinate isn't out of bounds. Parameters ---------- coord : numpy.ndarray 2D coordinate. matrix_shape : numpy.ndarray Shape of the matrix to where the coordinate should point. Returns ------- bool Whether the coordinate exists. \"\"\" return np . bitwise_and ( coord < matrix_shape , coord >= 0 ) . all () def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ): \"\"\"Computes the euclidean distance between two 3D points. Parameters ---------- x1 : int or float x coordinate of point 1. y1 : int or float y coordinate of point 1`. z1 : int or float z coordinate of point 1`. x2 : int or float x coordinate of point 2`. y2 : int or float y coordinate of point 2`. z2 : int or float z coordinate of point 2`. Returns ------- int or float Euclidean distance between two 3D points.. \"\"\" return (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) ** ( 1 / 2 ) def hashable_coord ( coord ): \"\"\"Transforms a coord list into a hashable type. Parameters ---------- coord : list 2D coordinate i.e (0,0). Returns ------- str A representation of the coord that is hashable. \"\"\" return str ( coord ) def find_landing_zone ( data ): \"\"\"Find the landing zone closest to the person xy coordinates considering the z terrain elevation.. Parameters ---------- data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). Returns ------- (list, int) Returns the shortest_path and the shortest_distance as a tuple. \"\"\" shortest_paths_dict = {} person_coord_hash = hashable_coord ( data . person_coord ) shortest_paths_dict [ person_coord_hash ] = {} shortest_paths_dict [ person_coord_hash ][ 'path' ] = [ data . person_coord ] shortest_paths_dict [ person_coord_hash ][ 'distance' ] = 0 base_neighbours = np . asarray ([[ 1 , 0 ], [ 0 , 1 ], [ 1 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ], [ - 1 , - 1 ], [ - 1 , 1 ], [ 1 , - 1 ]]) find_landing_zone_re ( data . person_coord , data , shortest_paths_dict , base_neighbours ) del shortest_paths_dict [ person_coord_hash ] for value in shortest_paths_dict . values (): if not value [ 'can_uav_land' ]: continue if 'shortest_distance' not in locals (): shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] continue if shortest_distance > value [ 'distance' ]: shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] if 'shortest_distance' in locals (): return shortest_path , shortest_distance else : return [], - 1 def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ): \"\"\"Recursive part of find_landing_zone. It doesn't return anything, it just updates the shortest_paths_dict. Parameters ---------- current_coord : list Description of parameter `current_coord`. data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). shortest_paths_dict : dict Dict of the path to each node. base_neighbours : list of lists Base neighbours of a matrix element i.e [[1, 0], [0, 1], [1, 1], [-1, 0], [0, -1], [-1, -1], [-1, 1], [1, -1]]. \"\"\" current_coord_hash = hashable_coord ( current_coord ) current_height = data . height_map [ current_coord [ 0 ]][ current_coord [ 1 ]] current_item = shortest_paths_dict [ current_coord_hash ] neighbour_list = base_neighbours + np . asarray ( current_coord ) for nb_coord in neighbour_list : # ignore coords that do not exist i.e (-1, 99999999) if not do_coord_exist ( nb_coord , data . adj_matrix . shape ): continue nb_label = data . adj_matrix [ nb_coord [ 0 ]][ nb_coord [ 1 ]] # ignore unreachable coords if not can_a_person_reach ( nb_label ): continue nb_coord_hashable = hashable_coord ( nb_coord ) nb_height = data . height_map [ nb_coord [ 0 ]][ nb_coord [ 1 ]] nb_distance = current_item [ 'distance' ] + \\ distance_between_3d_points ( current_coord [ 0 ], current_coord [ 1 ], abs ( current_height ), nb_coord [ 0 ], nb_coord [ 1 ], abs ( nb_height ) ) if nb_coord_hashable not in shortest_paths_dict : shortest_paths_dict [ nb_coord_hashable ] = {} else : if nb_distance > shortest_paths_dict [ nb_coord_hashable ][ 'distance' ]: continue nb_coord_item = shortest_paths_dict [ nb_coord_hashable ] nb_coord_item [ 'distance' ] = nb_distance nb_coord_item [ 'path' ] = shortest_paths_dict [ current_coord_hash ][ 'path' ][:] nb_coord_item [ 'path' ] . append ( nb_coord ) if can_uav_land ( nb_label ): nb_coord_item [ 'can_uav_land' ] = True else : nb_coord_item [ 'can_uav_land' ] = False find_landing_zone_re ( nb_coord , data , shortest_paths_dict , base_neighbours ) Functions distance_between_3d_points def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ) Computes the euclidean distance between two 3D points. Parameters: Name Type Description Default x1 int or float x coordinate of point 1. None y1 int or float y coordinate of point 1`. None z1 int or float z coordinate of point 1`. None x2 int or float x coordinate of point 2`. None y2 int or float y coordinate of point 2`. None z2 int or float z coordinate of point 2`. None Returns: Type Description int or float Euclidean distance between two 3D points.. View Source def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ): \"\"\"Computes the euclidean distance between two 3D points. Parameters ---------- x1 : int or float x coordinate of point 1. y1 : int or float y coordinate of point 1`. z1 : int or float z coordinate of point 1`. x2 : int or float x coordinate of point 2`. y2 : int or float y coordinate of point 2`. z2 : int or float z coordinate of point 2`. Returns ------- int or float Euclidean distance between two 3D points.. \"\"\" return (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) ** ( 1 / 2 ) do_coord_exist def do_coord_exist ( coord , matrix_shape ) Check if a 2D coordinate isn't out of bounds. Parameters: Name Type Description Default coord numpy.ndarray 2D coordinate. None matrix_shape numpy.ndarray Shape of the matrix to where the coordinate should point. None Returns: Type Description bool Whether the coordinate exists. View Source def do_coord_exist ( coord , matrix_shape ): \"\"\"Check if a 2D coordinate isn't out of bounds. Parameters ---------- coord : numpy.ndarray 2D coordinate. matrix_shape : numpy.ndarray Shape of the matrix to where the coordinate should point. Returns ------- bool Whether the coordinate exists. \"\"\" return np . bitwise_and ( coord < matrix_shape , coord >= 0 ). all () find_landing_zone def find_landing_zone ( data ) Find the landing zone closest to the person xy coordinates considering the z terrain elevation.. Parameters: Name Type Description Default data AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). None Returns: Type Description (list, int) Returns the shortest_path and the shortest_distance as a tuple. View Source def find_landing_zone ( data ) : \"\"\"Find the landing zone closest to the person xy coordinates considering the z terrain elevation.. Parameters ---------- data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). Returns ------- (list, int) Returns the shortest_path and the shortest_distance as a tuple. \"\"\" shortest_paths_dict = {} person_coord_hash = hashable_coord ( data . person_coord ) shortest_paths_dict [ person_coord_hash ] = {} shortest_paths_dict [ person_coord_hash ][ 'path' ] = [ data.person_coord ] shortest_paths_dict [ person_coord_hash ][ 'distance' ] = 0 base_neighbours = np . asarray ( [ [1, 0 ] , [ 0, 1 ] , [ 1, 1 ] , [ -1, 0 ] , [ 0, -1 ] , [ -1, -1 ] , [ -1, 1 ] , [ 1, -1 ] ] ) find_landing_zone_re ( data . person_coord , data , shortest_paths_dict , base_neighbours ) del shortest_paths_dict [ person_coord_hash ] for value in shortest_paths_dict . values () : if not value [ 'can_uav_land' ] : continue if 'shortest_distance' not in locals () : shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] continue if shortest_distance > value [ 'distance' ] : shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] if 'shortest_distance' in locals () : return shortest_path , shortest_distance else : return [] , - 1 find_landing_zone_re def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ) Recursive part of find_landing_zone. It doesn't return anything, it just updates the shortest_paths_dict. Parameters: Name Type Description Default current_coord list Description of parameter current_coord . None data AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). None shortest_paths_dict dict Dict of the path to each node. None base_neighbours list of lists Base neighbours of a matrix element i.e [[1, 0], [0, 1], [1, 1], [-1, 0], [0, -1], [-1, -1], [-1, 1], [1, -1]]. None View Source def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ) : \"\"\"Recursive part of find_landing_zone. It doesn't return anything, it just updates the shortest_paths_dict. Parameters ---------- current_coord : list Description of parameter `current_coord`. data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). shortest_paths_dict : dict Dict of the path to each node. base_neighbours : list of lists Base neighbours of a matrix element i.e [[1, 0], [0, 1], [1, 1], [-1, 0], [0, -1], [-1, -1], [-1, 1], [1, -1]]. \"\"\" current_coord_hash = hashable_coord ( current_coord ) current_height = data . height_map [ current_coord[0 ] ] [ current_coord[1 ] ] current_item = shortest_paths_dict [ current_coord_hash ] neighbour_list = base_neighbours + np . asarray ( current_coord ) for nb_coord in neighbour_list : # ignore coords that do not exist i . e ( - 1 , 99999999 ) if not do_coord_exist ( nb_coord , data . adj_matrix . shape ) : continue nb_label = data . adj_matrix [ nb_coord[0 ] ] [ nb_coord[1 ] ] # ignore unreachable coords if not can_a_person_reach ( nb_label ) : continue nb_coord_hashable = hashable_coord ( nb_coord ) nb_height = data . height_map [ nb_coord[0 ] ] [ nb_coord[1 ] ] nb_distance = current_item [ 'distance' ] + \\ distance_between_3d_points ( current_coord [ 0 ] , current_coord [ 1 ] , abs ( current_height ), nb_coord [ 0 ] , nb_coord [ 1 ] , abs ( nb_height ) ) if nb_coord_hashable not in shortest_paths_dict : shortest_paths_dict [ nb_coord_hashable ] = {} else : if nb_distance > shortest_paths_dict [ nb_coord_hashable ][ 'distance' ] : continue nb_coord_item = shortest_paths_dict [ nb_coord_hashable ] nb_coord_item [ 'distance' ] = nb_distance nb_coord_item [ 'path' ] = shortest_paths_dict [ current_coord_hash ][ 'path' ][ : ] nb_coord_item [ 'path' ] . append ( nb_coord ) if can_uav_land ( nb_label ) : nb_coord_item [ 'can_uav_land' ] = True else : nb_coord_item [ 'can_uav_land' ] = False find_landing_zone_re ( nb_coord , data , shortest_paths_dict , base_neighbours ) hashable_coord def hashable_coord ( coord ) Transforms a coord list into a hashable type. Parameters: Name Type Description Default coord list 2D coordinate i.e (0,0). None Returns: Type Description str A representation of the coord that is hashable. View Source def hashable_coord ( coord ): \"\"\"Transforms a coord list into a hashable type. Parameters ---------- coord : list 2D coordinate i.e (0,0). Returns ------- str A representation of the coord that is hashable. \"\"\" return str ( coord )","title":"Graph Utils"},{"location":"reference/landing_zone_detection/graph_utils/#module-landing_zone_detectiongraph_utils","text":"None None View Source import numpy as np from landing_zone_detection.label_utils import can_a_person_reach , can_uav_land def do_coord_exist ( coord , matrix_shape ): \"\"\"Check if a 2D coordinate isn't out of bounds. Parameters ---------- coord : numpy.ndarray 2D coordinate. matrix_shape : numpy.ndarray Shape of the matrix to where the coordinate should point. Returns ------- bool Whether the coordinate exists. \"\"\" return np . bitwise_and ( coord < matrix_shape , coord >= 0 ) . all () def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ): \"\"\"Computes the euclidean distance between two 3D points. Parameters ---------- x1 : int or float x coordinate of point 1. y1 : int or float y coordinate of point 1`. z1 : int or float z coordinate of point 1`. x2 : int or float x coordinate of point 2`. y2 : int or float y coordinate of point 2`. z2 : int or float z coordinate of point 2`. Returns ------- int or float Euclidean distance between two 3D points.. \"\"\" return (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) ** ( 1 / 2 ) def hashable_coord ( coord ): \"\"\"Transforms a coord list into a hashable type. Parameters ---------- coord : list 2D coordinate i.e (0,0). Returns ------- str A representation of the coord that is hashable. \"\"\" return str ( coord ) def find_landing_zone ( data ): \"\"\"Find the landing zone closest to the person xy coordinates considering the z terrain elevation.. Parameters ---------- data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). Returns ------- (list, int) Returns the shortest_path and the shortest_distance as a tuple. \"\"\" shortest_paths_dict = {} person_coord_hash = hashable_coord ( data . person_coord ) shortest_paths_dict [ person_coord_hash ] = {} shortest_paths_dict [ person_coord_hash ][ 'path' ] = [ data . person_coord ] shortest_paths_dict [ person_coord_hash ][ 'distance' ] = 0 base_neighbours = np . asarray ([[ 1 , 0 ], [ 0 , 1 ], [ 1 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ], [ - 1 , - 1 ], [ - 1 , 1 ], [ 1 , - 1 ]]) find_landing_zone_re ( data . person_coord , data , shortest_paths_dict , base_neighbours ) del shortest_paths_dict [ person_coord_hash ] for value in shortest_paths_dict . values (): if not value [ 'can_uav_land' ]: continue if 'shortest_distance' not in locals (): shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] continue if shortest_distance > value [ 'distance' ]: shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] if 'shortest_distance' in locals (): return shortest_path , shortest_distance else : return [], - 1 def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ): \"\"\"Recursive part of find_landing_zone. It doesn't return anything, it just updates the shortest_paths_dict. Parameters ---------- current_coord : list Description of parameter `current_coord`. data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). shortest_paths_dict : dict Dict of the path to each node. base_neighbours : list of lists Base neighbours of a matrix element i.e [[1, 0], [0, 1], [1, 1], [-1, 0], [0, -1], [-1, -1], [-1, 1], [1, -1]]. \"\"\" current_coord_hash = hashable_coord ( current_coord ) current_height = data . height_map [ current_coord [ 0 ]][ current_coord [ 1 ]] current_item = shortest_paths_dict [ current_coord_hash ] neighbour_list = base_neighbours + np . asarray ( current_coord ) for nb_coord in neighbour_list : # ignore coords that do not exist i.e (-1, 99999999) if not do_coord_exist ( nb_coord , data . adj_matrix . shape ): continue nb_label = data . adj_matrix [ nb_coord [ 0 ]][ nb_coord [ 1 ]] # ignore unreachable coords if not can_a_person_reach ( nb_label ): continue nb_coord_hashable = hashable_coord ( nb_coord ) nb_height = data . height_map [ nb_coord [ 0 ]][ nb_coord [ 1 ]] nb_distance = current_item [ 'distance' ] + \\ distance_between_3d_points ( current_coord [ 0 ], current_coord [ 1 ], abs ( current_height ), nb_coord [ 0 ], nb_coord [ 1 ], abs ( nb_height ) ) if nb_coord_hashable not in shortest_paths_dict : shortest_paths_dict [ nb_coord_hashable ] = {} else : if nb_distance > shortest_paths_dict [ nb_coord_hashable ][ 'distance' ]: continue nb_coord_item = shortest_paths_dict [ nb_coord_hashable ] nb_coord_item [ 'distance' ] = nb_distance nb_coord_item [ 'path' ] = shortest_paths_dict [ current_coord_hash ][ 'path' ][:] nb_coord_item [ 'path' ] . append ( nb_coord ) if can_uav_land ( nb_label ): nb_coord_item [ 'can_uav_land' ] = True else : nb_coord_item [ 'can_uav_land' ] = False find_landing_zone_re ( nb_coord , data , shortest_paths_dict , base_neighbours )","title":"Module landing_zone_detection.graph_utils"},{"location":"reference/landing_zone_detection/graph_utils/#functions","text":"","title":"Functions"},{"location":"reference/landing_zone_detection/graph_utils/#distance_between_3d_points","text":"def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ) Computes the euclidean distance between two 3D points. Parameters: Name Type Description Default x1 int or float x coordinate of point 1. None y1 int or float y coordinate of point 1`. None z1 int or float z coordinate of point 1`. None x2 int or float x coordinate of point 2`. None y2 int or float y coordinate of point 2`. None z2 int or float z coordinate of point 2`. None Returns: Type Description int or float Euclidean distance between two 3D points.. View Source def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ): \"\"\"Computes the euclidean distance between two 3D points. Parameters ---------- x1 : int or float x coordinate of point 1. y1 : int or float y coordinate of point 1`. z1 : int or float z coordinate of point 1`. x2 : int or float x coordinate of point 2`. y2 : int or float y coordinate of point 2`. z2 : int or float z coordinate of point 2`. Returns ------- int or float Euclidean distance between two 3D points.. \"\"\" return (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) ** ( 1 / 2 )","title":"distance_between_3d_points"},{"location":"reference/landing_zone_detection/graph_utils/#do_coord_exist","text":"def do_coord_exist ( coord , matrix_shape ) Check if a 2D coordinate isn't out of bounds. Parameters: Name Type Description Default coord numpy.ndarray 2D coordinate. None matrix_shape numpy.ndarray Shape of the matrix to where the coordinate should point. None Returns: Type Description bool Whether the coordinate exists. View Source def do_coord_exist ( coord , matrix_shape ): \"\"\"Check if a 2D coordinate isn't out of bounds. Parameters ---------- coord : numpy.ndarray 2D coordinate. matrix_shape : numpy.ndarray Shape of the matrix to where the coordinate should point. Returns ------- bool Whether the coordinate exists. \"\"\" return np . bitwise_and ( coord < matrix_shape , coord >= 0 ). all ()","title":"do_coord_exist"},{"location":"reference/landing_zone_detection/graph_utils/#find_landing_zone","text":"def find_landing_zone ( data ) Find the landing zone closest to the person xy coordinates considering the z terrain elevation.. Parameters: Name Type Description Default data AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). None Returns: Type Description (list, int) Returns the shortest_path and the shortest_distance as a tuple. View Source def find_landing_zone ( data ) : \"\"\"Find the landing zone closest to the person xy coordinates considering the z terrain elevation.. Parameters ---------- data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). Returns ------- (list, int) Returns the shortest_path and the shortest_distance as a tuple. \"\"\" shortest_paths_dict = {} person_coord_hash = hashable_coord ( data . person_coord ) shortest_paths_dict [ person_coord_hash ] = {} shortest_paths_dict [ person_coord_hash ][ 'path' ] = [ data.person_coord ] shortest_paths_dict [ person_coord_hash ][ 'distance' ] = 0 base_neighbours = np . asarray ( [ [1, 0 ] , [ 0, 1 ] , [ 1, 1 ] , [ -1, 0 ] , [ 0, -1 ] , [ -1, -1 ] , [ -1, 1 ] , [ 1, -1 ] ] ) find_landing_zone_re ( data . person_coord , data , shortest_paths_dict , base_neighbours ) del shortest_paths_dict [ person_coord_hash ] for value in shortest_paths_dict . values () : if not value [ 'can_uav_land' ] : continue if 'shortest_distance' not in locals () : shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] continue if shortest_distance > value [ 'distance' ] : shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] if 'shortest_distance' in locals () : return shortest_path , shortest_distance else : return [] , - 1","title":"find_landing_zone"},{"location":"reference/landing_zone_detection/graph_utils/#find_landing_zone_re","text":"def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ) Recursive part of find_landing_zone. It doesn't return anything, it just updates the shortest_paths_dict. Parameters: Name Type Description Default current_coord list Description of parameter current_coord . None data AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). None shortest_paths_dict dict Dict of the path to each node. None base_neighbours list of lists Base neighbours of a matrix element i.e [[1, 0], [0, 1], [1, 1], [-1, 0], [0, -1], [-1, -1], [-1, 1], [1, -1]]. None View Source def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ) : \"\"\"Recursive part of find_landing_zone. It doesn't return anything, it just updates the shortest_paths_dict. Parameters ---------- current_coord : list Description of parameter `current_coord`. data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). shortest_paths_dict : dict Dict of the path to each node. base_neighbours : list of lists Base neighbours of a matrix element i.e [[1, 0], [0, 1], [1, 1], [-1, 0], [0, -1], [-1, -1], [-1, 1], [1, -1]]. \"\"\" current_coord_hash = hashable_coord ( current_coord ) current_height = data . height_map [ current_coord[0 ] ] [ current_coord[1 ] ] current_item = shortest_paths_dict [ current_coord_hash ] neighbour_list = base_neighbours + np . asarray ( current_coord ) for nb_coord in neighbour_list : # ignore coords that do not exist i . e ( - 1 , 99999999 ) if not do_coord_exist ( nb_coord , data . adj_matrix . shape ) : continue nb_label = data . adj_matrix [ nb_coord[0 ] ] [ nb_coord[1 ] ] # ignore unreachable coords if not can_a_person_reach ( nb_label ) : continue nb_coord_hashable = hashable_coord ( nb_coord ) nb_height = data . height_map [ nb_coord[0 ] ] [ nb_coord[1 ] ] nb_distance = current_item [ 'distance' ] + \\ distance_between_3d_points ( current_coord [ 0 ] , current_coord [ 1 ] , abs ( current_height ), nb_coord [ 0 ] , nb_coord [ 1 ] , abs ( nb_height ) ) if nb_coord_hashable not in shortest_paths_dict : shortest_paths_dict [ nb_coord_hashable ] = {} else : if nb_distance > shortest_paths_dict [ nb_coord_hashable ][ 'distance' ] : continue nb_coord_item = shortest_paths_dict [ nb_coord_hashable ] nb_coord_item [ 'distance' ] = nb_distance nb_coord_item [ 'path' ] = shortest_paths_dict [ current_coord_hash ][ 'path' ][ : ] nb_coord_item [ 'path' ] . append ( nb_coord ) if can_uav_land ( nb_label ) : nb_coord_item [ 'can_uav_land' ] = True else : nb_coord_item [ 'can_uav_land' ] = False find_landing_zone_re ( nb_coord , data , shortest_paths_dict , base_neighbours )","title":"find_landing_zone_re"},{"location":"reference/landing_zone_detection/graph_utils/#hashable_coord","text":"def hashable_coord ( coord ) Transforms a coord list into a hashable type. Parameters: Name Type Description Default coord list 2D coordinate i.e (0,0). None Returns: Type Description str A representation of the coord that is hashable. View Source def hashable_coord ( coord ): \"\"\"Transforms a coord list into a hashable type. Parameters ---------- coord : list 2D coordinate i.e (0,0). Returns ------- str A representation of the coord that is hashable. \"\"\" return str ( coord )","title":"hashable_coord"},{"location":"reference/landing_zone_detection/label_utils/","text":"Module landing_zone_detection.label_utils None None View Source UAV_CAN_LAND_PERSON_CAN_REACH = 1 UAV_CANNOT_LAND_PERSON_CAN_REACH = 0 UAV_CANNOT_LAND_PERSON_CANNOT_REACH = - 1 def can_uav_land ( label ): \"\"\"Checks if an UAV can reach a position labelled with \" label \". Parameters ---------- label : int Label of a position in the image. Returns ------- boolean Whether an UAV can reach a position labelled with \" label \". \"\"\" return label == UAV_CAN_LAND_PERSON_CAN_REACH def can_a_person_reach ( label ): \"\"\"Checks if a person can reach a position labelled with \" label \". Parameters ---------- label : int Label of a position in the image. Returns ------- bool Whether a person can reach a position labelled with \" label \". \"\"\" return label == UAV_CAN_LAND_PERSON_CAN_REACH or \\ label == UAV_CANNOT_LAND_PERSON_CAN_REACH Variables UAV_CANNOT_LAND_PERSON_CANNOT_REACH UAV_CANNOT_LAND_PERSON_CAN_REACH UAV_CAN_LAND_PERSON_CAN_REACH Functions can_a_person_reach def can_a_person_reach ( label ) Checks if a person can reach a position labelled with \"label\". Parameters: Name Type Description Default label int Label of a position in the image. None Returns: Type Description bool Whether a person can reach a position labelled with \"label\". View Source def can_a_person_reach ( label ): \"\"\"Checks if a person can reach a position labelled with \" label \". Parameters ---------- label : int Label of a position in the image. Returns ------- bool Whether a person can reach a position labelled with \" label \". \"\"\" return label == UAV_CAN_LAND_PERSON_CAN_REACH or \\ label == UAV_CANNOT_LAND_PERSON_CAN_REACH can_uav_land def can_uav_land ( label ) Checks if an UAV can reach a position labelled with \"label\". Parameters: Name Type Description Default label int Label of a position in the image. None Returns: Type Description boolean Whether an UAV can reach a position labelled with \"label\". View Source def can_uav_land ( label ): \"\"\"Checks if an UAV can reach a position labelled with \" label \". Parameters ---------- label : int Label of a position in the image. Returns ------- boolean Whether an UAV can reach a position labelled with \" label \". \"\"\" return label == UAV_CAN_LAND_PERSON_CAN_REACH","title":"Label Utils"},{"location":"reference/landing_zone_detection/label_utils/#module-landing_zone_detectionlabel_utils","text":"None None View Source UAV_CAN_LAND_PERSON_CAN_REACH = 1 UAV_CANNOT_LAND_PERSON_CAN_REACH = 0 UAV_CANNOT_LAND_PERSON_CANNOT_REACH = - 1 def can_uav_land ( label ): \"\"\"Checks if an UAV can reach a position labelled with \" label \". Parameters ---------- label : int Label of a position in the image. Returns ------- boolean Whether an UAV can reach a position labelled with \" label \". \"\"\" return label == UAV_CAN_LAND_PERSON_CAN_REACH def can_a_person_reach ( label ): \"\"\"Checks if a person can reach a position labelled with \" label \". Parameters ---------- label : int Label of a position in the image. Returns ------- bool Whether a person can reach a position labelled with \" label \". \"\"\" return label == UAV_CAN_LAND_PERSON_CAN_REACH or \\ label == UAV_CANNOT_LAND_PERSON_CAN_REACH","title":"Module landing_zone_detection.label_utils"},{"location":"reference/landing_zone_detection/label_utils/#variables","text":"UAV_CANNOT_LAND_PERSON_CANNOT_REACH UAV_CANNOT_LAND_PERSON_CAN_REACH UAV_CAN_LAND_PERSON_CAN_REACH","title":"Variables"},{"location":"reference/landing_zone_detection/label_utils/#functions","text":"","title":"Functions"},{"location":"reference/landing_zone_detection/label_utils/#can_a_person_reach","text":"def can_a_person_reach ( label ) Checks if a person can reach a position labelled with \"label\". Parameters: Name Type Description Default label int Label of a position in the image. None Returns: Type Description bool Whether a person can reach a position labelled with \"label\". View Source def can_a_person_reach ( label ): \"\"\"Checks if a person can reach a position labelled with \" label \". Parameters ---------- label : int Label of a position in the image. Returns ------- bool Whether a person can reach a position labelled with \" label \". \"\"\" return label == UAV_CAN_LAND_PERSON_CAN_REACH or \\ label == UAV_CANNOT_LAND_PERSON_CAN_REACH","title":"can_a_person_reach"},{"location":"reference/landing_zone_detection/label_utils/#can_uav_land","text":"def can_uav_land ( label ) Checks if an UAV can reach a position labelled with \"label\". Parameters: Name Type Description Default label int Label of a position in the image. None Returns: Type Description boolean Whether an UAV can reach a position labelled with \"label\". View Source def can_uav_land ( label ): \"\"\"Checks if an UAV can reach a position labelled with \" label \". Parameters ---------- label : int Label of a position in the image. Returns ------- boolean Whether an UAV can reach a position labelled with \" label \". \"\"\" return label == UAV_CAN_LAND_PERSON_CAN_REACH","title":"can_uav_land"},{"location":"reference/landing_zone_detection/visualization_utils/","text":"Module landing_zone_detection.visualization_utils None None View Source import cv2 import numpy as np import matplotlib.pyplot as plt def item_from_color ( color , col_size = 32 , row_size = 32 ): \"\"\"Generates a matrix of size (col_size, row_size, len(color)) if color is 1D or a matrix of size (col_size, row_size) if color is a digit. Parameters ---------- color : int or list RGB, gray or binary color i.e [255,255,255], 255 or 1. Maybe even RGBA or whatever. col_size : int Color size. row_size : int Size of a row. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" return np . repeat ( [ np . repeat ([ color ], col_size , axis = 0 )], row_size , axis = 0 ) def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ], 0 : [ 168 , 50 , 125 ], - 1 : [ 0 , 0 , 255 ]}, num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. value_to_color : dict Dict to map each value in the adj_matrix to a differenct color. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) value_to_item = { 1 : item_from_color ( value_to_color [ 1 ]), 0 : item_from_color ( value_to_color [ 0 ]), - 1 : item_from_color ( value_to_color [ - 1 ]), } for i , col in enumerate ( adj_matrix ): x1 = col_size * i x2 = col_size * ( i + 1 ) for j , value in enumerate ( col ): y1 = row_size * j y2 = row_size * ( j + 1 ) img [ x1 : x2 , y1 : y2 , :] = value_to_item [ value ] . copy () return img def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- node_list : list List of node coordinates i.e [(0,0), (0,1), (0,2), (1,2)]. item_color : list Color of each node/item. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) item = item_from_color ( item_color ) for node in node_list : x1 = col_size * node [ 0 ] x2 = col_size * ( node [ 0 ] + 1 ) y1 = row_size * node [ 1 ] y2 = row_size * ( node [ 1 ] + 1 ) img [ x1 : x2 , y1 : y2 , :] = item . copy () return img def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = []): \"\"\"Method to plot the frame. Parameters ---------- frame : numpy.ndarray 2D matrix representing an image. width : int Frame width. height : int Frame height. images_to_overlay : list List of images to overlay on top of the frame. \"\"\" # overlay images on the frame if images_to_overlay : img_to_overlay = images_to_overlay [ 0 ] for img in images_to_overlay [ 1 :]: img_to_overlay += img if images_to_overlay : frame = cv2 . addWeighted ( img_to_overlay , 1.0 , frame , 1.0 , 0.0 ) # resize to desired size with bilinear interpolation frame = cv2 . resize ( frame , ( width , height ), interpolation = cv2 . INTER_LINEAR ) # convert from BGR to RGB for plotting purposes frame = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2RGB ) # plot the resulting frame plt . imshow ( frame ) plt . show () Functions adj_matrix_to_image def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ], 0 : [ 168 , 50 , 125 ], - 1 : [ 0 , 0 , 255 ]}, num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype =< class ' numpy . uint8 '> ) Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters: Name Type Description Default adj_matrix numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. None value_to_color dict Dict to map each value in the adj_matrix to a differenct color. None num_cols int Number of columns in each adj_matrix (or height_map) item. None num_rows int Number of rows in each adj_matrix (or height_map) item. None col_size int Width of each adj_matrix (or height_map) item. None row_size int Height of each adj_matrix (or height_map) item. None img_dtype int Data type of the resulting image. None Returns: Type Description numpy.ndarray 2D matrix representing an image. View Source def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80, 30, 50 ] , 0 : [ 168, 50, 125 ] , - 1 : [ 0, 0, 255 ] } , num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ) : \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. value_to_color : dict Dict to map each value in the adj_matrix to a differenct color. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) value_to_item = { 1 : item_from_color ( value_to_color [ 1 ] ), 0 : item_from_color ( value_to_color [ 0 ] ), - 1 : item_from_color ( value_to_color [ -1 ] ), } for i , col in enumerate ( adj_matrix ) : x1 = col_size * i x2 = col_size * ( i + 1 ) for j , value in enumerate ( col ) : y1 = row_size * j y2 = row_size * ( j + 1 ) img [ x1:x2, y1:y2, : ] = value_to_item [ value ] . copy () return img item_from_color def item_from_color ( color , col_size = 32 , row_size = 32 ) Generates a matrix of size (col_size, row_size, len(color)) if color is 1D or a matrix of size (col_size, row_size) if color is a digit. Parameters: Name Type Description Default color int or list RGB, gray or binary color i.e [255,255,255], 255 or 1. Maybe even RGBA or whatever. None col_size int Color size. None row_size int Size of a row. None Returns: Type Description numpy.ndarray 2D matrix representing an image. View Source def item_from_color ( color , col_size = 32 , row_size = 32 ) : \"\"\"Generates a matrix of size (col_size, row_size, len(color)) if color is 1D or a matrix of size (col_size, row_size) if color is a digit. Parameters ---------- color : int or list RGB, gray or binary color i.e [255,255,255], 255 or 1. Maybe even RGBA or whatever. col_size : int Color size. row_size : int Size of a row. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" return np . repeat ( [ np.repeat([color ] , col_size , axis = 0 ) ] , row_size , axis = 0 ) node_list_to_image def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype =< class ' numpy . uint8 '> ) Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters: Name Type Description Default node_list list List of node coordinates i.e [(0,0), (0,1), (0,2), (1,2)]. None item_color list Color of each node/item. None num_cols int Number of columns in each adj_matrix (or height_map) item. None num_rows int Number of rows in each adj_matrix (or height_map) item. None col_size int Width of each adj_matrix (or height_map) item. None row_size int Height of each adj_matrix (or height_map) item. None img_dtype int Data type of the resulting image. None Returns: Type Description numpy.ndarray 2D matrix representing an image. View Source def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- node_list : list List of node coordinates i.e [(0,0), (0,1), (0,2), (1,2)]. item_color : list Color of each node/item. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) item = item_from_color ( item_color ) for node in node_list : x1 = col_size * node [ 0 ] x2 = col_size * ( node [ 0 ] + 1 ) y1 = row_size * node [ 1 ] y2 = row_size * ( node [ 1 ] + 1 ) img [ x1 : x2 , y1 : y2 , :] = item . copy () return img plot_frame def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = [] ) Method to plot the frame. Parameters: Name Type Description Default frame numpy.ndarray 2D matrix representing an image. None width int Frame width. None height int Frame height. None images_to_overlay list List of images to overlay on top of the frame. None View Source def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = []): \"\"\"Method to plot the frame. Parameters ---------- frame : numpy.ndarray 2D matrix representing an image. width : int Frame width. height : int Frame height. images_to_overlay : list List of images to overlay on top of the frame. \"\"\" # overlay images on the frame if images_to_overlay : img_to_overlay = images_to_overlay [ 0 ] for img in images_to_overlay [ 1 :]: img_to_overlay += img if images_to_overlay : frame = cv2 . addWeighted ( img_to_overlay , 1 . 0 , frame , 1 . 0 , 0 . 0 ) # resize to desired size with bilinear interpolation frame = cv2 . resize ( frame , ( width , height ), interpolation = cv2 . INTER_LINEAR ) # convert from BGR to RGB for plotting purposes frame = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2RGB ) # plot the resulting frame plt . imshow ( frame ) plt . show ()","title":"Visualization Utils"},{"location":"reference/landing_zone_detection/visualization_utils/#module-landing_zone_detectionvisualization_utils","text":"None None View Source import cv2 import numpy as np import matplotlib.pyplot as plt def item_from_color ( color , col_size = 32 , row_size = 32 ): \"\"\"Generates a matrix of size (col_size, row_size, len(color)) if color is 1D or a matrix of size (col_size, row_size) if color is a digit. Parameters ---------- color : int or list RGB, gray or binary color i.e [255,255,255], 255 or 1. Maybe even RGBA or whatever. col_size : int Color size. row_size : int Size of a row. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" return np . repeat ( [ np . repeat ([ color ], col_size , axis = 0 )], row_size , axis = 0 ) def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ], 0 : [ 168 , 50 , 125 ], - 1 : [ 0 , 0 , 255 ]}, num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. value_to_color : dict Dict to map each value in the adj_matrix to a differenct color. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) value_to_item = { 1 : item_from_color ( value_to_color [ 1 ]), 0 : item_from_color ( value_to_color [ 0 ]), - 1 : item_from_color ( value_to_color [ - 1 ]), } for i , col in enumerate ( adj_matrix ): x1 = col_size * i x2 = col_size * ( i + 1 ) for j , value in enumerate ( col ): y1 = row_size * j y2 = row_size * ( j + 1 ) img [ x1 : x2 , y1 : y2 , :] = value_to_item [ value ] . copy () return img def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- node_list : list List of node coordinates i.e [(0,0), (0,1), (0,2), (1,2)]. item_color : list Color of each node/item. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) item = item_from_color ( item_color ) for node in node_list : x1 = col_size * node [ 0 ] x2 = col_size * ( node [ 0 ] + 1 ) y1 = row_size * node [ 1 ] y2 = row_size * ( node [ 1 ] + 1 ) img [ x1 : x2 , y1 : y2 , :] = item . copy () return img def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = []): \"\"\"Method to plot the frame. Parameters ---------- frame : numpy.ndarray 2D matrix representing an image. width : int Frame width. height : int Frame height. images_to_overlay : list List of images to overlay on top of the frame. \"\"\" # overlay images on the frame if images_to_overlay : img_to_overlay = images_to_overlay [ 0 ] for img in images_to_overlay [ 1 :]: img_to_overlay += img if images_to_overlay : frame = cv2 . addWeighted ( img_to_overlay , 1.0 , frame , 1.0 , 0.0 ) # resize to desired size with bilinear interpolation frame = cv2 . resize ( frame , ( width , height ), interpolation = cv2 . INTER_LINEAR ) # convert from BGR to RGB for plotting purposes frame = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2RGB ) # plot the resulting frame plt . imshow ( frame ) plt . show ()","title":"Module landing_zone_detection.visualization_utils"},{"location":"reference/landing_zone_detection/visualization_utils/#functions","text":"","title":"Functions"},{"location":"reference/landing_zone_detection/visualization_utils/#adj_matrix_to_image","text":"def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ], 0 : [ 168 , 50 , 125 ], - 1 : [ 0 , 0 , 255 ]}, num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype =< class ' numpy . uint8 '> ) Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters: Name Type Description Default adj_matrix numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. None value_to_color dict Dict to map each value in the adj_matrix to a differenct color. None num_cols int Number of columns in each adj_matrix (or height_map) item. None num_rows int Number of rows in each adj_matrix (or height_map) item. None col_size int Width of each adj_matrix (or height_map) item. None row_size int Height of each adj_matrix (or height_map) item. None img_dtype int Data type of the resulting image. None Returns: Type Description numpy.ndarray 2D matrix representing an image. View Source def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80, 30, 50 ] , 0 : [ 168, 50, 125 ] , - 1 : [ 0, 0, 255 ] } , num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ) : \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. value_to_color : dict Dict to map each value in the adj_matrix to a differenct color. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) value_to_item = { 1 : item_from_color ( value_to_color [ 1 ] ), 0 : item_from_color ( value_to_color [ 0 ] ), - 1 : item_from_color ( value_to_color [ -1 ] ), } for i , col in enumerate ( adj_matrix ) : x1 = col_size * i x2 = col_size * ( i + 1 ) for j , value in enumerate ( col ) : y1 = row_size * j y2 = row_size * ( j + 1 ) img [ x1:x2, y1:y2, : ] = value_to_item [ value ] . copy () return img","title":"adj_matrix_to_image"},{"location":"reference/landing_zone_detection/visualization_utils/#item_from_color","text":"def item_from_color ( color , col_size = 32 , row_size = 32 ) Generates a matrix of size (col_size, row_size, len(color)) if color is 1D or a matrix of size (col_size, row_size) if color is a digit. Parameters: Name Type Description Default color int or list RGB, gray or binary color i.e [255,255,255], 255 or 1. Maybe even RGBA or whatever. None col_size int Color size. None row_size int Size of a row. None Returns: Type Description numpy.ndarray 2D matrix representing an image. View Source def item_from_color ( color , col_size = 32 , row_size = 32 ) : \"\"\"Generates a matrix of size (col_size, row_size, len(color)) if color is 1D or a matrix of size (col_size, row_size) if color is a digit. Parameters ---------- color : int or list RGB, gray or binary color i.e [255,255,255], 255 or 1. Maybe even RGBA or whatever. col_size : int Color size. row_size : int Size of a row. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" return np . repeat ( [ np.repeat([color ] , col_size , axis = 0 ) ] , row_size , axis = 0 )","title":"item_from_color"},{"location":"reference/landing_zone_detection/visualization_utils/#node_list_to_image","text":"def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype =< class ' numpy . uint8 '> ) Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters: Name Type Description Default node_list list List of node coordinates i.e [(0,0), (0,1), (0,2), (1,2)]. None item_color list Color of each node/item. None num_cols int Number of columns in each adj_matrix (or height_map) item. None num_rows int Number of rows in each adj_matrix (or height_map) item. None col_size int Width of each adj_matrix (or height_map) item. None row_size int Height of each adj_matrix (or height_map) item. None img_dtype int Data type of the resulting image. None Returns: Type Description numpy.ndarray 2D matrix representing an image. View Source def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- node_list : list List of node coordinates i.e [(0,0), (0,1), (0,2), (1,2)]. item_color : list Color of each node/item. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) item = item_from_color ( item_color ) for node in node_list : x1 = col_size * node [ 0 ] x2 = col_size * ( node [ 0 ] + 1 ) y1 = row_size * node [ 1 ] y2 = row_size * ( node [ 1 ] + 1 ) img [ x1 : x2 , y1 : y2 , :] = item . copy () return img","title":"node_list_to_image"},{"location":"reference/landing_zone_detection/visualization_utils/#plot_frame","text":"def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = [] ) Method to plot the frame. Parameters: Name Type Description Default frame numpy.ndarray 2D matrix representing an image. None width int Frame width. None height int Frame height. None images_to_overlay list List of images to overlay on top of the frame. None View Source def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = []): \"\"\"Method to plot the frame. Parameters ---------- frame : numpy.ndarray 2D matrix representing an image. width : int Frame width. height : int Frame height. images_to_overlay : list List of images to overlay on top of the frame. \"\"\" # overlay images on the frame if images_to_overlay : img_to_overlay = images_to_overlay [ 0 ] for img in images_to_overlay [ 1 :]: img_to_overlay += img if images_to_overlay : frame = cv2 . addWeighted ( img_to_overlay , 1 . 0 , frame , 1 . 0 , 0 . 0 ) # resize to desired size with bilinear interpolation frame = cv2 . resize ( frame , ( width , height ), interpolation = cv2 . INTER_LINEAR ) # convert from BGR to RGB for plotting purposes frame = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2RGB ) # plot the resulting frame plt . imshow ( frame ) plt . show ()","title":"plot_frame"}]}