{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Landing Zone Detection Determine which of the reachable detected landing zones is closest to the person. List Number : X Discipline Subject : Graphs II Students Number Student 17/0146251 Jo\u00e3o Lucas Zarbi\u00e9lli 19/0046945 Leonardo Michalski Miranda About App Gif Video (pt-br, download link ) How to run Language : Python. Frameworks : OpenCV; Jupyter Voil\u00e0; BinderHub. Access the app or the notebook with the BinderHub server. How to use References Jupyter et al., \"Binder 2.0 - Reproducible, Interactive, Sharable Environments for Science at Scale.\" Proceedings of the 17th Python in Science Conference. 2018. doi://10.25080/Majora-4af1f417-011","title":"Home"},{"location":"#landing-zone-detection","text":"Determine which of the reachable detected landing zones is closest to the person. List Number : X Discipline Subject : Graphs II","title":"Landing Zone Detection"},{"location":"#students","text":"Number Student 17/0146251 Jo\u00e3o Lucas Zarbi\u00e9lli 19/0046945 Leonardo Michalski Miranda","title":"Students"},{"location":"#about","text":"","title":"About"},{"location":"#app-gif","text":"","title":"App Gif"},{"location":"#video-pt-br-download-link","text":"","title":"Video (pt-br, download link)"},{"location":"#how-to-run","text":"Language : Python. Frameworks : OpenCV; Jupyter Voil\u00e0; BinderHub. Access the app or the notebook with the BinderHub server.","title":"How to run"},{"location":"#how-to-use","text":"","title":"How to use"},{"location":"#references","text":"Jupyter et al., \"Binder 2.0 - Reproducible, Interactive, Sharable Environments for Science at Scale.\" Proceedings of the 17th Python in Science Conference. 2018. doi://10.25080/Majora-4af1f417-011","title":"References"},{"location":"reference/landing_zone_detection/","text":"Module landing_zone_detection None None Sub-modules landing_zone_detection.data landing_zone_detection.graph_utils landing_zone_detection.label_utils landing_zone_detection.visualization_utils","title":"Index"},{"location":"reference/landing_zone_detection/#module-landing_zone_detection","text":"None None","title":"Module landing_zone_detection"},{"location":"reference/landing_zone_detection/#sub-modules","text":"landing_zone_detection.data landing_zone_detection.graph_utils landing_zone_detection.label_utils landing_zone_detection.visualization_utils","title":"Sub-modules"},{"location":"reference/landing_zone_detection/data/","text":"Module landing_zone_detection.data None None View Source import numpy as np import cv2 from landing_zone_detection import label_utils import os class AerialImageData ( object ): \"\"\"Aerial image and its surrounding data. Parameters ---------- <<<<<<< HEAD frame : numpy.ndarray Frame (image) taken by the flying UAV. adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. height_map : numpy.ndarray Depth estimation of the frame. Same shape as the adj_matrix. person_coord : list (x, y) coordinate of a person in the adj_matrix. This is the person who's supposed to receive the UAV. ======= frame : np.empty, deafult=Required np.empty representing a image. adj_matrix : np.empty, deafult=Required np.empty representing a adj_matrix. height_map : np.empty, deafult=Required np.empty representing a adj_matrix. person_coord : List, deafult=Required List with x and y that represents the person coordenate. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" def __init__ ( self , frame = None , adj_matrix = None , height_map = None , person_coord = None ): self . frame = frame self . adj_matrix = adj_matrix self . height_map = height_map self . person_coord = person_coord # UTILITIES TO GENERATE RANDOM DATA MOCK_DATA_PATH = 'mock_data' TERRAIN_OPTIONS_IMAGES = [ os . path . join ( MOCK_DATA_PATH , 'grass.png' ), os . path . join ( MOCK_DATA_PATH , 'grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'tree.png' ), os . path . join ( MOCK_DATA_PATH , 'tree_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'tree_pincushion.png' ), ] PERSON_OPTIONS_IMAGES = [ os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass_pincushion.png' ), ] TERRAIN_OPTIONS_LABELS = [ label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass_barrel label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree_barrel label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree_pincushion ] PERSON_OPTIONS_LABELS = [ label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass_pincushion ] TERRAIN_OPTIONS_HEIGHTS = [ 0 , # grass 0.8 , # grass_barrel - 1.2 , # grass_pincushion 0 , # tall_grass 0.8 , # tall_grass_barrel - 1.2 , # tall_grass_pincushion 0 , # tree 0.8 , # tree_barrel - 1.2 , # tree_pincushion ] PERSON_OPTIONS_HEIGHTS = [ 0 , # person_in_tall_grass 0.8 , # person_in_tall_grass_barrel - 1.2 , # person_in_tall_grass_pincushion 0 , # person_on_grass 0.8 , # person_on_grass_barrel - 1.2 , # person_on_grass_pincushion ] class RandomAerialImageDataGenerator ( object ): \"\"\"Class to generate random AerialImageData object using the given terrain and person options. Parameters ---------- <<<<<<< HEAD width : int Image width. height : int Image height. channels : int Number of channels in the image. dtype : np.uint8 Data type of the frame. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. terrain_options_images : list Each item of the image can randomly assume one of this images. terrain_options_labels : list Labels of each option in terrain_options_images. terrain_options_heights : list Estimated depth (height from the drone to the ground) of each option in terrain_options_images. person_options_images : list Until now, only one random item of the image can assume one of this images. In other words: only one person per image. person_options_labels : list Labels of each person_options in person_options_images. person_options_heights : list Estimated depth (height from the drone to the ground) of each option in person_options_images. ======= width : Int, default=224 Image width. height : Int, default=224 Image height'. channels : Int, default=3 Description of parameter `channels`. dtype : np.uint8, default=np.uint8 Data type of frame. col_size : Int, default=32 column size`. row_size : Int, default=32 Row size`. terrain_options_images : List, default=terrain_options_images List of terrain images. terrain_options_labels : List, default=terrain_options_labels List of terrain options labels`. terrain_options_heights : List, default=terrain_options_heights List of terrain options heights. person_options_images : List, default=person_options_images List of person images. person_options_labels : List, default=person_options_labels List of person options images labels. person_options_heights : List, default=person_options_heights List of person options heights. >>>>>>> babf6803825d127003e989374de11514beea5d59 Attributes ---------- num_cols : type Number of columns in each adj_matrix (or height_map) item. num_rows : type Number of rows in each adj_matrix (or height_map) item. \"\"\" def __init__ ( self , width = 224 , height = 224 , channels = 3 , dtype = np . uint8 , col_size = 32 , row_size = 32 , terrain_options_images = TERRAIN_OPTIONS_IMAGES , terrain_options_labels = TERRAIN_OPTIONS_LABELS , terrain_options_heights = TERRAIN_OPTIONS_HEIGHTS , person_options_images = PERSON_OPTIONS_IMAGES , person_options_labels = PERSON_OPTIONS_LABELS , person_options_heights = PERSON_OPTIONS_HEIGHTS ): self . width = width self . height = height self . channels = channels self . dtype = dtype self . col_size = col_size self . row_size = row_size self . terrain_options_images = terrain_options_images self . terrain_options_labels = terrain_options_labels self . terrain_options_heights = terrain_options_heights self . person_options_images = person_options_images self . person_options_labels = person_options_labels self . person_options_heights = person_options_heights self . num_cols = self . width // self . col_size self . num_rows = self . height // self . row_size self . terrain_options_images = self . load_img_items ( self . terrain_options_images ) self . person_options_images = self . load_img_items ( self . person_options_images ) def __read_img_item ( self , filename , ** kwargs ): \"\"\"Read an image item from filename. Parameters ---------- <<<<<<< HEAD filename : str File path. **kwargs : dict **kwargs. Returns ------- numpy.ndarray 2D matrix representing an image. ======= filename : type, default=Required File path. **kwargs : Any, deafult=Automatically Determined `**kwargs`. Returns ------- type Open image. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return cv2 . imread ( filename , ** kwargs ) def __resize_img_item ( self , img_item , resize_method = cv2 . INTER_LINEAR , ** kwargs ): \"\"\"Resize an image item. Parameters ---------- <<<<<<< HEAD img_item : numpy.ndarray 2D matrix representing an image. resize_method : int Type of the resize method i.e cv2.INTER_LINEAR. **kwargs : dict **kwargs Returns ------- numpy.ndarray Resized image. ======= img_item : Bytes Open image. resize_method : method, default=cv2.INTER_LINEAR, Type of resize method. **kwargs : type **kwargs` Returns ------- type Risezed image. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return cv2 . resize ( src = img_item , dsize = ( self . col_size , self . row_size ), interpolation = resize_method , ** kwargs ) def load_img_items ( self , img_items ): \"\"\"Read and transform a list of image items. Parameters ---------- <<<<<<< HEAD img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. ======= img_items : List List of images. Returns ------- type List of risezed images. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items def generate ( self ): \"\"\"Generates a random AerialImageData object using the given terrain and person options. Returns ------- <<<<<<< HEAD AerialImageData Aerial image and its surrounding data. ======= type Dict. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ) ) # populate with the terrain options for i in range ( self . num_cols ): x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ): y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i , j ] return data Variables MOCK_DATA_PATH PERSON_OPTIONS_HEIGHTS PERSON_OPTIONS_IMAGES PERSON_OPTIONS_LABELS TERRAIN_OPTIONS_HEIGHTS TERRAIN_OPTIONS_IMAGES TERRAIN_OPTIONS_LABELS Classes AerialImageData class AerialImageData ( frame = None , adj_matrix = None , height_map = None , person_coord = None ) View Source class AerialImageData ( object ): \"\"\"Aerial image and its surrounding data. Parameters ---------- <<<<<<< HEAD frame : numpy.ndarray Frame (image) taken by the flying UAV. adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. height_map : numpy.ndarray Depth estimation of the frame. Same shape as the adj_matrix. person_coord : list (x, y) coordinate of a person in the adj_matrix. This is the person who's supposed to receive the UAV. ======= frame : np.empty, deafult=Required np.empty representing a image. adj_matrix : np.empty, deafult=Required np.empty representing a adj_matrix. height_map : np.empty, deafult=Required np.empty representing a adj_matrix. person_coord : List, deafult=Required List with x and y that represents the person coordenate. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" def __init__ ( self , frame = None , adj_matrix = None , height_map = None , person_coord = None ): self . frame = frame self . adj_matrix = adj_matrix self . height_map = height_map self . person_coord = person_coord RandomAerialImageDataGenerator class RandomAerialImageDataGenerator ( width = 224 , height = 224 , channels = 3 , dtype =< class ' numpy . uint8 '>, col_size = 32 , row_size = 32 , terrain_options_images = [ 'mock_data/grass.png' , 'mock_data/grass_barrel.png' , 'mock_data/grass_pincushion.png' , 'mock_data/tall_grass.png' , 'mock_data/tall_grass_barrel.png' , 'mock_data/tall_grass_pincushion.png' , 'mock_data/tree.png' , 'mock_data/tree_barrel.png' , 'mock_data/tree_pincushion.png' ], terrain_options_labels = [ 1 , 1 , 1 , 0 , 0 , 0 , - 1 , - 1 , - 1 ], terrain_options_heights = [ 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 ], person_options_images = [ 'mock_data/person_in_tall_grass.png' , 'mock_data/person_in_tall_grass_barrel.png' , 'mock_data/person_in_tall_grass_pincushion.png' , 'mock_data/person_on_grass.png' , 'mock_data/person_on_grass_barrel.png' , 'mock_data/person_on_grass_pincushion.png' ], person_options_labels = [ 0 , 0 , 0 , 0 , 0 , 0 ], person_options_heights = [ 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 ] ) View Source class RandomAerialImageDataGenerator ( object ): \"\"\"Class to generate random AerialImageData object using the given terrain and person options. Parameters ---------- <<<<<<< HEAD width : int Image width. height : int Image height. channels : int Number of channels in the image. dtype : np.uint8 Data type of the frame. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. terrain_options_images : list Each item of the image can randomly assume one of this images. terrain_options_labels : list Labels of each option in terrain_options_images. terrain_options_heights : list Estimated depth (height from the drone to the ground) of each option in terrain_options_images. person_options_images : list Until now, only one random item of the image can assume one of this images. In other words: only one person per image. person_options_labels : list Labels of each person_options in person_options_images. person_options_heights : list Estimated depth (height from the drone to the ground) of each option in person_options_images. ======= width : Int, default=224 Image width. height : Int, default=224 Image height'. channels : Int, default=3 Description of parameter `channels`. dtype : np.uint8, default=np.uint8 Data type of frame. col_size : Int, default=32 column size`. row_size : Int, default=32 Row size`. terrain_options_images : List, default=terrain_options_images List of terrain images. terrain_options_labels : List, default=terrain_options_labels List of terrain options labels`. terrain_options_heights : List, default=terrain_options_heights List of terrain options heights. person_options_images : List, default=person_options_images List of person images. person_options_labels : List, default=person_options_labels List of person options images labels. person_options_heights : List, default=person_options_heights List of person options heights. >>>>>>> babf6803825d127003e989374de11514beea5d59 Attributes ---------- num_cols : type Number of columns in each adj_matrix (or height_map) item. num_rows : type Number of rows in each adj_matrix (or height_map) item. \"\"\" def __init__ ( self , width = 224 , height = 224 , channels = 3 , dtype = np . uint8 , col_size = 32 , row_size = 32 , terrain_options_images = TERRAIN_OPTIONS_IMAGES , terrain_options_labels = TERRAIN_OPTIONS_LABELS , terrain_options_heights = TERRAIN_OPTIONS_HEIGHTS , person_options_images = PERSON_OPTIONS_IMAGES , person_options_labels = PERSON_OPTIONS_LABELS , person_options_heights = PERSON_OPTIONS_HEIGHTS ): self . width = width self . height = height self . channels = channels self . dtype = dtype self . col_size = col_size self . row_size = row_size self . terrain_options_images = terrain_options_images self . terrain_options_labels = terrain_options_labels self . terrain_options_heights = terrain_options_heights self . person_options_images = person_options_images self . person_options_labels = person_options_labels self . person_options_heights = person_options_heights self . num_cols = self . width // self . col_size self . num_rows = self . height // self . row_size self . terrain_options_images = self . load_img_items ( self . terrain_options_images ) self . person_options_images = self . load_img_items ( self . person_options_images ) def __read_img_item ( self , filename , ** kwargs ): \"\"\"Read an image item from filename. Parameters ---------- <<<<<<< HEAD filename : str File path. **kwargs : dict **kwargs. Returns ------- numpy.ndarray 2D matrix representing an image. ======= filename : type, default=Required File path. **kwargs : Any, deafult=Automatically Determined `**kwargs`. Returns ------- type Open image. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return cv2 . imread ( filename , ** kwargs ) def __resize_img_item ( self , img_item , resize_method = cv2 . INTER_LINEAR , ** kwargs ): \"\"\"Resize an image item. Parameters ---------- <<<<<<< HEAD img_item : numpy.ndarray 2D matrix representing an image. resize_method : int Type of the resize method i.e cv2.INTER_LINEAR. **kwargs : dict **kwargs Returns ------- numpy.ndarray Resized image. ======= img_item : Bytes Open image. resize_method : method, default=cv2.INTER_LINEAR, Type of resize method. **kwargs : type **kwargs` Returns ------- type Risezed image. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return cv2 . resize ( src = img_item , dsize = ( self . col_size , self . row_size ), interpolation = resize_method , ** kwargs ) def load_img_items ( self , img_items ): \"\"\"Read and transform a list of image items. Parameters ---------- <<<<<<< HEAD img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. ======= img_items : List List of images. Returns ------- type List of risezed images. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items def generate ( self ): \"\"\"Generates a random AerialImageData object using the given terrain and person options. Returns ------- <<<<<<< HEAD AerialImageData Aerial image and its surrounding data. ======= type Dict. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ) ) # populate with the terrain options for i in range ( self . num_cols ): x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ): y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i , j ] return data Methods generate def generate ( self ) Generates a random AerialImageData object using the given terrain and person options. Returns ------- <<<<<<< HEAD AerialImageData Aerial image and its surrounding data. ======= type Dict. babf6803825d127003e989374de11514beea5d59 View Source def generate ( self ) : \"\"\"Generates a random AerialImageData object using the given terrain and person options. Returns ------- <<<<<<< HEAD AerialImageData Aerial image and its surrounding data. ======= type Dict. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ) ) # populate with the terrain options for i in range ( self . num_cols ) : x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ) : y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1:x2, y1:y2, : ] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1:x2, y1:y2, : ] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i, j ] return data load_img_items def load_img_items ( self , img_items ) Read and transform a list of image items. Parameters ---------- <<<<<<< HEAD img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. ======= img_items : List List of images. Returns ------- type List of risezed images. babf6803825d127003e989374de11514beea5d59 View Source def load_img_items ( self , img_items ): \"\"\"Read and transform a list of image items. Parameters ---------- <<<<<<< HEAD img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. ======= img_items : List List of images. Returns ------- type List of risezed images. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items","title":"Data"},{"location":"reference/landing_zone_detection/data/#module-landing_zone_detectiondata","text":"None None View Source import numpy as np import cv2 from landing_zone_detection import label_utils import os class AerialImageData ( object ): \"\"\"Aerial image and its surrounding data. Parameters ---------- <<<<<<< HEAD frame : numpy.ndarray Frame (image) taken by the flying UAV. adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. height_map : numpy.ndarray Depth estimation of the frame. Same shape as the adj_matrix. person_coord : list (x, y) coordinate of a person in the adj_matrix. This is the person who's supposed to receive the UAV. ======= frame : np.empty, deafult=Required np.empty representing a image. adj_matrix : np.empty, deafult=Required np.empty representing a adj_matrix. height_map : np.empty, deafult=Required np.empty representing a adj_matrix. person_coord : List, deafult=Required List with x and y that represents the person coordenate. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" def __init__ ( self , frame = None , adj_matrix = None , height_map = None , person_coord = None ): self . frame = frame self . adj_matrix = adj_matrix self . height_map = height_map self . person_coord = person_coord # UTILITIES TO GENERATE RANDOM DATA MOCK_DATA_PATH = 'mock_data' TERRAIN_OPTIONS_IMAGES = [ os . path . join ( MOCK_DATA_PATH , 'grass.png' ), os . path . join ( MOCK_DATA_PATH , 'grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'tall_grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'tree.png' ), os . path . join ( MOCK_DATA_PATH , 'tree_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'tree_pincushion.png' ), ] PERSON_OPTIONS_IMAGES = [ os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'person_in_tall_grass_pincushion.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass_barrel.png' ), os . path . join ( MOCK_DATA_PATH , 'person_on_grass_pincushion.png' ), ] TERRAIN_OPTIONS_LABELS = [ label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass_barrel label_utils . UAV_CAN_LAND_PERSON_CAN_REACH , # grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # tall_grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree_barrel label_utils . UAV_CANNOT_LAND_PERSON_CANNOT_REACH , # tree_pincushion ] PERSON_OPTIONS_LABELS = [ label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_in_tall_grass_pincushion label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass_barrel label_utils . UAV_CANNOT_LAND_PERSON_CAN_REACH , # person_on_grass_pincushion ] TERRAIN_OPTIONS_HEIGHTS = [ 0 , # grass 0.8 , # grass_barrel - 1.2 , # grass_pincushion 0 , # tall_grass 0.8 , # tall_grass_barrel - 1.2 , # tall_grass_pincushion 0 , # tree 0.8 , # tree_barrel - 1.2 , # tree_pincushion ] PERSON_OPTIONS_HEIGHTS = [ 0 , # person_in_tall_grass 0.8 , # person_in_tall_grass_barrel - 1.2 , # person_in_tall_grass_pincushion 0 , # person_on_grass 0.8 , # person_on_grass_barrel - 1.2 , # person_on_grass_pincushion ] class RandomAerialImageDataGenerator ( object ): \"\"\"Class to generate random AerialImageData object using the given terrain and person options. Parameters ---------- <<<<<<< HEAD width : int Image width. height : int Image height. channels : int Number of channels in the image. dtype : np.uint8 Data type of the frame. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. terrain_options_images : list Each item of the image can randomly assume one of this images. terrain_options_labels : list Labels of each option in terrain_options_images. terrain_options_heights : list Estimated depth (height from the drone to the ground) of each option in terrain_options_images. person_options_images : list Until now, only one random item of the image can assume one of this images. In other words: only one person per image. person_options_labels : list Labels of each person_options in person_options_images. person_options_heights : list Estimated depth (height from the drone to the ground) of each option in person_options_images. ======= width : Int, default=224 Image width. height : Int, default=224 Image height'. channels : Int, default=3 Description of parameter `channels`. dtype : np.uint8, default=np.uint8 Data type of frame. col_size : Int, default=32 column size`. row_size : Int, default=32 Row size`. terrain_options_images : List, default=terrain_options_images List of terrain images. terrain_options_labels : List, default=terrain_options_labels List of terrain options labels`. terrain_options_heights : List, default=terrain_options_heights List of terrain options heights. person_options_images : List, default=person_options_images List of person images. person_options_labels : List, default=person_options_labels List of person options images labels. person_options_heights : List, default=person_options_heights List of person options heights. >>>>>>> babf6803825d127003e989374de11514beea5d59 Attributes ---------- num_cols : type Number of columns in each adj_matrix (or height_map) item. num_rows : type Number of rows in each adj_matrix (or height_map) item. \"\"\" def __init__ ( self , width = 224 , height = 224 , channels = 3 , dtype = np . uint8 , col_size = 32 , row_size = 32 , terrain_options_images = TERRAIN_OPTIONS_IMAGES , terrain_options_labels = TERRAIN_OPTIONS_LABELS , terrain_options_heights = TERRAIN_OPTIONS_HEIGHTS , person_options_images = PERSON_OPTIONS_IMAGES , person_options_labels = PERSON_OPTIONS_LABELS , person_options_heights = PERSON_OPTIONS_HEIGHTS ): self . width = width self . height = height self . channels = channels self . dtype = dtype self . col_size = col_size self . row_size = row_size self . terrain_options_images = terrain_options_images self . terrain_options_labels = terrain_options_labels self . terrain_options_heights = terrain_options_heights self . person_options_images = person_options_images self . person_options_labels = person_options_labels self . person_options_heights = person_options_heights self . num_cols = self . width // self . col_size self . num_rows = self . height // self . row_size self . terrain_options_images = self . load_img_items ( self . terrain_options_images ) self . person_options_images = self . load_img_items ( self . person_options_images ) def __read_img_item ( self , filename , ** kwargs ): \"\"\"Read an image item from filename. Parameters ---------- <<<<<<< HEAD filename : str File path. **kwargs : dict **kwargs. Returns ------- numpy.ndarray 2D matrix representing an image. ======= filename : type, default=Required File path. **kwargs : Any, deafult=Automatically Determined `**kwargs`. Returns ------- type Open image. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return cv2 . imread ( filename , ** kwargs ) def __resize_img_item ( self , img_item , resize_method = cv2 . INTER_LINEAR , ** kwargs ): \"\"\"Resize an image item. Parameters ---------- <<<<<<< HEAD img_item : numpy.ndarray 2D matrix representing an image. resize_method : int Type of the resize method i.e cv2.INTER_LINEAR. **kwargs : dict **kwargs Returns ------- numpy.ndarray Resized image. ======= img_item : Bytes Open image. resize_method : method, default=cv2.INTER_LINEAR, Type of resize method. **kwargs : type **kwargs` Returns ------- type Risezed image. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return cv2 . resize ( src = img_item , dsize = ( self . col_size , self . row_size ), interpolation = resize_method , ** kwargs ) def load_img_items ( self , img_items ): \"\"\"Read and transform a list of image items. Parameters ---------- <<<<<<< HEAD img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. ======= img_items : List List of images. Returns ------- type List of risezed images. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items def generate ( self ): \"\"\"Generates a random AerialImageData object using the given terrain and person options. Returns ------- <<<<<<< HEAD AerialImageData Aerial image and its surrounding data. ======= type Dict. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ) ) # populate with the terrain options for i in range ( self . num_cols ): x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ): y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i , j ] return data","title":"Module landing_zone_detection.data"},{"location":"reference/landing_zone_detection/data/#variables","text":"MOCK_DATA_PATH PERSON_OPTIONS_HEIGHTS PERSON_OPTIONS_IMAGES PERSON_OPTIONS_LABELS TERRAIN_OPTIONS_HEIGHTS TERRAIN_OPTIONS_IMAGES TERRAIN_OPTIONS_LABELS","title":"Variables"},{"location":"reference/landing_zone_detection/data/#classes","text":"","title":"Classes"},{"location":"reference/landing_zone_detection/data/#aerialimagedata","text":"class AerialImageData ( frame = None , adj_matrix = None , height_map = None , person_coord = None ) View Source class AerialImageData ( object ): \"\"\"Aerial image and its surrounding data. Parameters ---------- <<<<<<< HEAD frame : numpy.ndarray Frame (image) taken by the flying UAV. adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. height_map : numpy.ndarray Depth estimation of the frame. Same shape as the adj_matrix. person_coord : list (x, y) coordinate of a person in the adj_matrix. This is the person who's supposed to receive the UAV. ======= frame : np.empty, deafult=Required np.empty representing a image. adj_matrix : np.empty, deafult=Required np.empty representing a adj_matrix. height_map : np.empty, deafult=Required np.empty representing a adj_matrix. person_coord : List, deafult=Required List with x and y that represents the person coordenate. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" def __init__ ( self , frame = None , adj_matrix = None , height_map = None , person_coord = None ): self . frame = frame self . adj_matrix = adj_matrix self . height_map = height_map self . person_coord = person_coord","title":"AerialImageData"},{"location":"reference/landing_zone_detection/data/#randomaerialimagedatagenerator","text":"class RandomAerialImageDataGenerator ( width = 224 , height = 224 , channels = 3 , dtype =< class ' numpy . uint8 '>, col_size = 32 , row_size = 32 , terrain_options_images = [ 'mock_data/grass.png' , 'mock_data/grass_barrel.png' , 'mock_data/grass_pincushion.png' , 'mock_data/tall_grass.png' , 'mock_data/tall_grass_barrel.png' , 'mock_data/tall_grass_pincushion.png' , 'mock_data/tree.png' , 'mock_data/tree_barrel.png' , 'mock_data/tree_pincushion.png' ], terrain_options_labels = [ 1 , 1 , 1 , 0 , 0 , 0 , - 1 , - 1 , - 1 ], terrain_options_heights = [ 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 ], person_options_images = [ 'mock_data/person_in_tall_grass.png' , 'mock_data/person_in_tall_grass_barrel.png' , 'mock_data/person_in_tall_grass_pincushion.png' , 'mock_data/person_on_grass.png' , 'mock_data/person_on_grass_barrel.png' , 'mock_data/person_on_grass_pincushion.png' ], person_options_labels = [ 0 , 0 , 0 , 0 , 0 , 0 ], person_options_heights = [ 0 , 0.8 , - 1.2 , 0 , 0.8 , - 1.2 ] ) View Source class RandomAerialImageDataGenerator ( object ): \"\"\"Class to generate random AerialImageData object using the given terrain and person options. Parameters ---------- <<<<<<< HEAD width : int Image width. height : int Image height. channels : int Number of channels in the image. dtype : np.uint8 Data type of the frame. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. terrain_options_images : list Each item of the image can randomly assume one of this images. terrain_options_labels : list Labels of each option in terrain_options_images. terrain_options_heights : list Estimated depth (height from the drone to the ground) of each option in terrain_options_images. person_options_images : list Until now, only one random item of the image can assume one of this images. In other words: only one person per image. person_options_labels : list Labels of each person_options in person_options_images. person_options_heights : list Estimated depth (height from the drone to the ground) of each option in person_options_images. ======= width : Int, default=224 Image width. height : Int, default=224 Image height'. channels : Int, default=3 Description of parameter `channels`. dtype : np.uint8, default=np.uint8 Data type of frame. col_size : Int, default=32 column size`. row_size : Int, default=32 Row size`. terrain_options_images : List, default=terrain_options_images List of terrain images. terrain_options_labels : List, default=terrain_options_labels List of terrain options labels`. terrain_options_heights : List, default=terrain_options_heights List of terrain options heights. person_options_images : List, default=person_options_images List of person images. person_options_labels : List, default=person_options_labels List of person options images labels. person_options_heights : List, default=person_options_heights List of person options heights. >>>>>>> babf6803825d127003e989374de11514beea5d59 Attributes ---------- num_cols : type Number of columns in each adj_matrix (or height_map) item. num_rows : type Number of rows in each adj_matrix (or height_map) item. \"\"\" def __init__ ( self , width = 224 , height = 224 , channels = 3 , dtype = np . uint8 , col_size = 32 , row_size = 32 , terrain_options_images = TERRAIN_OPTIONS_IMAGES , terrain_options_labels = TERRAIN_OPTIONS_LABELS , terrain_options_heights = TERRAIN_OPTIONS_HEIGHTS , person_options_images = PERSON_OPTIONS_IMAGES , person_options_labels = PERSON_OPTIONS_LABELS , person_options_heights = PERSON_OPTIONS_HEIGHTS ): self . width = width self . height = height self . channels = channels self . dtype = dtype self . col_size = col_size self . row_size = row_size self . terrain_options_images = terrain_options_images self . terrain_options_labels = terrain_options_labels self . terrain_options_heights = terrain_options_heights self . person_options_images = person_options_images self . person_options_labels = person_options_labels self . person_options_heights = person_options_heights self . num_cols = self . width // self . col_size self . num_rows = self . height // self . row_size self . terrain_options_images = self . load_img_items ( self . terrain_options_images ) self . person_options_images = self . load_img_items ( self . person_options_images ) def __read_img_item ( self , filename , ** kwargs ): \"\"\"Read an image item from filename. Parameters ---------- <<<<<<< HEAD filename : str File path. **kwargs : dict **kwargs. Returns ------- numpy.ndarray 2D matrix representing an image. ======= filename : type, default=Required File path. **kwargs : Any, deafult=Automatically Determined `**kwargs`. Returns ------- type Open image. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return cv2 . imread ( filename , ** kwargs ) def __resize_img_item ( self , img_item , resize_method = cv2 . INTER_LINEAR , ** kwargs ): \"\"\"Resize an image item. Parameters ---------- <<<<<<< HEAD img_item : numpy.ndarray 2D matrix representing an image. resize_method : int Type of the resize method i.e cv2.INTER_LINEAR. **kwargs : dict **kwargs Returns ------- numpy.ndarray Resized image. ======= img_item : Bytes Open image. resize_method : method, default=cv2.INTER_LINEAR, Type of resize method. **kwargs : type **kwargs` Returns ------- type Risezed image. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return cv2 . resize ( src = img_item , dsize = ( self . col_size , self . row_size ), interpolation = resize_method , ** kwargs ) def load_img_items ( self , img_items ): \"\"\"Read and transform a list of image items. Parameters ---------- <<<<<<< HEAD img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. ======= img_items : List List of images. Returns ------- type List of risezed images. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items def generate ( self ): \"\"\"Generates a random AerialImageData object using the given terrain and person options. Returns ------- <<<<<<< HEAD AerialImageData Aerial image and its surrounding data. ======= type Dict. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ) ) # populate with the terrain options for i in range ( self . num_cols ): x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ): y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1 : x2 , y1 : y2 , :] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i , j ] return data","title":"RandomAerialImageDataGenerator"},{"location":"reference/landing_zone_detection/data/#methods","text":"","title":"Methods"},{"location":"reference/landing_zone_detection/data/#generate","text":"def generate ( self ) Generates a random AerialImageData object using the given terrain and person options. Returns ------- <<<<<<< HEAD AerialImageData Aerial image and its surrounding data. ======= type Dict. babf6803825d127003e989374de11514beea5d59 View Source def generate ( self ) : \"\"\"Generates a random AerialImageData object using the given terrain and person options. Returns ------- <<<<<<< HEAD AerialImageData Aerial image and its surrounding data. ======= type Dict. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" data = AerialImageData ( frame = np . empty ( ( self . num_cols * self . col_size , self . num_rows * self . row_size , self . channels , ), dtype = self . dtype , ), adj_matrix = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ), height_map = np . empty ( ( self . num_cols , self . num_rows ), dtype = np . int8 , ) ) # populate with the terrain options for i in range ( self . num_cols ) : x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) for j in range ( self . num_rows ) : y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . terrain_options_images ) ) data . height_map [ i ][ j ] = self . terrain_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = \\ self . terrain_options_labels [ chosen_item_idx ] data . frame [ x1:x2, y1:y2, : ] = \\ self . terrain_options_images [ chosen_item_idx ] # choose a single terrain item randomly and subtitute it with a person i = np . random . choice ( self . num_cols ) x1 = self . col_size * i x2 = self . col_size * ( i + 1 ) j = np . random . choice ( self . num_rows ) y1 = self . row_size * j y2 = self . row_size * ( j + 1 ) chosen_item_idx = np . random . choice ( len ( self . person_options_images )) data . height_map [ i ][ j ] = self . person_options_heights [ chosen_item_idx ] data . adj_matrix [ i ][ j ] = self . person_options_labels [ chosen_item_idx ] data . frame [ x1:x2, y1:y2, : ] = self . person_options_images [ chosen_item_idx ] # store the coordinate of the person data . person_coord = [ i, j ] return data","title":"generate"},{"location":"reference/landing_zone_detection/data/#load_img_items","text":"def load_img_items ( self , img_items ) Read and transform a list of image items. Parameters ---------- <<<<<<< HEAD img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. ======= img_items : List List of images. Returns ------- type List of risezed images. babf6803825d127003e989374de11514beea5d59 View Source def load_img_items ( self , img_items ): \"\"\"Read and transform a list of image items. Parameters ---------- <<<<<<< HEAD img_items : list List of paths, or list of numpy.ndarrays. Returns ------- list List of the transformed images. ======= img_items : List List of images. Returns ------- type List of risezed images. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" for i , img in enumerate ( img_items ): # read images if type ( img ) == str : img = self . __read_img_item ( img ) # transform images img = self . __resize_img_item ( img ) img_items [ i ] = img return img_items","title":"load_img_items"},{"location":"reference/landing_zone_detection/graph_utils/","text":"Module landing_zone_detection.graph_utils None None View Source import numpy as np from landing_zone_detection.label_utils import can_a_person_reach , can_uav_land def do_coord_exist ( coord , matrix_shape ): \"\"\"Check if a 2D coordinate isn't out of bounds. Parameters ---------- coord : numpy.ndarray 2D coordinate. matrix_shape : numpy.ndarray Shape of the matrix to where the coordinate should point. Returns ------- bool Whether the coordinate exists. \"\"\" return np . bitwise_and ( coord < matrix_shape , coord >= 0 ) . all () def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ): \"\"\"Computes the euclidean distance between two 3D points. Parameters ---------- x1 : int or float x coordinate of point 1. y1 : int or float y coordinate of point 1`. z1 : int or float z coordinate of point 1`. x2 : int or float x coordinate of point 2`. y2 : int or float y coordinate of point 2`. z2 : int or float z coordinate of point 2`. Returns ------- int or float Euclidean distance between two 3D points.. \"\"\" return (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) ** ( 1 / 2 ) def hashable_coord ( coord ): \"\"\"Transforms a coord list into a hashable type. Parameters ---------- coord : list 2D coordinate i.e (0,0). Returns ------- str A representation of the coord that is hashable. \"\"\" return str ( coord ) def find_landing_zone ( data ): \"\"\"Find the landing zone closest to the person xy coordinates considering the z terrain elevation.. Parameters ---------- data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). Returns ------- (list, int) Returns the shortest_path and the shortest_distance as a tuple. \"\"\" shortest_paths_dict = {} person_coord_hash = hashable_coord ( data . person_coord ) shortest_paths_dict [ person_coord_hash ] = {} shortest_paths_dict [ person_coord_hash ][ 'path' ] = [ data . person_coord ] shortest_paths_dict [ person_coord_hash ][ 'distance' ] = 0 base_neighbours = np . asarray ([[ 1 , 0 ], [ 0 , 1 ], [ 1 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ], [ - 1 , - 1 ], [ - 1 , 1 ], [ 1 , - 1 ]]) find_landing_zone_re ( data . person_coord , data , shortest_paths_dict , base_neighbours ) del shortest_paths_dict [ person_coord_hash ] for value in shortest_paths_dict . values (): if not value [ 'can_uav_land' ]: continue if 'shortest_distance' not in locals (): shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] continue if shortest_distance > value [ 'distance' ]: shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] if 'shortest_distance' in locals (): return shortest_path , shortest_distance else : return [], - 1 def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ): \"\"\"Recursive part of find_landing_zone. Parameters ---------- data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). Returns ------- (list, int) Returns the shortest_path and the shortest_distance as a tuple. Parameters ---------- current_coord : type Description of parameter `current_coord`. data : type Description of parameter `data`. shortest_paths_dict : type Description of parameter `shortest_paths_dict`. base_neighbours : type Description of parameter `base_neighbours`. Returns ------- type Description of returned object. \"\"\" current_coord_hash = hashable_coord ( current_coord ) current_height = data . height_map [ current_coord [ 0 ]][ current_coord [ 1 ]] current_item = shortest_paths_dict [ current_coord_hash ] neighbour_list = base_neighbours + np . asarray ( current_coord ) for nb_coord in neighbour_list : # ignore coords that do not exist i.e (-1, 99999999) if not do_coord_exist ( nb_coord , data . adj_matrix . shape ): continue nb_label = data . adj_matrix [ nb_coord [ 0 ]][ nb_coord [ 1 ]] # ignore unreachable coords if not can_a_person_reach ( nb_label ): continue nb_coord_hashable = hashable_coord ( nb_coord ) nb_height = data . height_map [ nb_coord [ 0 ]][ nb_coord [ 1 ]] nb_distance = current_item [ 'distance' ] + \\ distance_between_3d_points ( current_coord [ 0 ], current_coord [ 1 ], abs ( current_height ), nb_coord [ 0 ], nb_coord [ 1 ], abs ( nb_height ) ) if nb_coord_hashable not in shortest_paths_dict : shortest_paths_dict [ nb_coord_hashable ] = {} else : if nb_distance > shortest_paths_dict [ nb_coord_hashable ][ 'distance' ]: continue nb_coord_item = shortest_paths_dict [ nb_coord_hashable ] nb_coord_item [ 'distance' ] = nb_distance nb_coord_item [ 'path' ] = shortest_paths_dict [ current_coord_hash ][ 'path' ][:] nb_coord_item [ 'path' ] . append ( nb_coord ) if can_uav_land ( nb_label ): nb_coord_item [ 'can_uav_land' ] = True else : nb_coord_item [ 'can_uav_land' ] = False find_landing_zone_re ( nb_coord , data , shortest_paths_dict , base_neighbours ) Functions distance_between_3d_points def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ) Computes the euclidean distance between two 3D points. Parameters: Name Type Description Default x1 int or float x coordinate of point 1. None y1 int or float y coordinate of point 1`. None z1 int or float z coordinate of point 1`. None x2 int or float x coordinate of point 2`. None y2 int or float y coordinate of point 2`. None z2 int or float z coordinate of point 2`. None Returns: Type Description int or float Euclidean distance between two 3D points.. View Source def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ): \"\"\"Computes the euclidean distance between two 3D points. Parameters ---------- x1 : int or float x coordinate of point 1. y1 : int or float y coordinate of point 1`. z1 : int or float z coordinate of point 1`. x2 : int or float x coordinate of point 2`. y2 : int or float y coordinate of point 2`. z2 : int or float z coordinate of point 2`. Returns ------- int or float Euclidean distance between two 3D points.. \"\"\" return (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) ** ( 1 / 2 ) do_coord_exist def do_coord_exist ( coord , matrix_shape ) Check if a 2D coordinate isn't out of bounds. Parameters: Name Type Description Default coord numpy.ndarray 2D coordinate. None matrix_shape numpy.ndarray Shape of the matrix to where the coordinate should point. None Returns: Type Description bool Whether the coordinate exists. View Source def do_coord_exist ( coord , matrix_shape ): \"\"\"Check if a 2D coordinate isn't out of bounds. Parameters ---------- coord : numpy.ndarray 2D coordinate. matrix_shape : numpy.ndarray Shape of the matrix to where the coordinate should point. Returns ------- bool Whether the coordinate exists. \"\"\" return np . bitwise_and ( coord < matrix_shape , coord >= 0 ). all () find_landing_zone def find_landing_zone ( data ) Find the landing zone closest to the person xy coordinates considering the z terrain elevation.. Parameters: Name Type Description Default data AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). None Returns: Type Description (list, int) Returns the shortest_path and the shortest_distance as a tuple. View Source def find_landing_zone ( data ) : \"\"\"Find the landing zone closest to the person xy coordinates considering the z terrain elevation.. Parameters ---------- data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). Returns ------- (list, int) Returns the shortest_path and the shortest_distance as a tuple. \"\"\" shortest_paths_dict = {} person_coord_hash = hashable_coord ( data . person_coord ) shortest_paths_dict [ person_coord_hash ] = {} shortest_paths_dict [ person_coord_hash ][ 'path' ] = [ data.person_coord ] shortest_paths_dict [ person_coord_hash ][ 'distance' ] = 0 base_neighbours = np . asarray ( [ [1, 0 ] , [ 0, 1 ] , [ 1, 1 ] , [ -1, 0 ] , [ 0, -1 ] , [ -1, -1 ] , [ -1, 1 ] , [ 1, -1 ] ] ) find_landing_zone_re ( data . person_coord , data , shortest_paths_dict , base_neighbours ) del shortest_paths_dict [ person_coord_hash ] for value in shortest_paths_dict . values () : if not value [ 'can_uav_land' ] : continue if 'shortest_distance' not in locals () : shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] continue if shortest_distance > value [ 'distance' ] : shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] if 'shortest_distance' in locals () : return shortest_path , shortest_distance else : return [] , - 1 find_landing_zone_re def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ) Recursive part of find_landing_zone. Parameters: Name Type Description Default data AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). None current_coord type Description of parameter current_coord . None data type Description of parameter data . None shortest_paths_dict type Description of parameter shortest_paths_dict . None base_neighbours type Description of parameter base_neighbours . None Returns: Type Description (list, int) Returns the shortest_path and the shortest_distance as a tuple. View Source def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ) : \"\"\"Recursive part of find_landing_zone. Parameters ---------- data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). Returns ------- (list, int) Returns the shortest_path and the shortest_distance as a tuple. Parameters ---------- current_coord : type Description of parameter `current_coord`. data : type Description of parameter `data`. shortest_paths_dict : type Description of parameter `shortest_paths_dict`. base_neighbours : type Description of parameter `base_neighbours`. Returns ------- type Description of returned object. \"\"\" current_coord_hash = hashable_coord ( current_coord ) current_height = data . height_map [ current_coord[0 ] ] [ current_coord[1 ] ] current_item = shortest_paths_dict [ current_coord_hash ] neighbour_list = base_neighbours + np . asarray ( current_coord ) for nb_coord in neighbour_list : # ignore coords that do not exist i . e ( - 1 , 99999999 ) if not do_coord_exist ( nb_coord , data . adj_matrix . shape ) : continue nb_label = data . adj_matrix [ nb_coord[0 ] ] [ nb_coord[1 ] ] # ignore unreachable coords if not can_a_person_reach ( nb_label ) : continue nb_coord_hashable = hashable_coord ( nb_coord ) nb_height = data . height_map [ nb_coord[0 ] ] [ nb_coord[1 ] ] nb_distance = current_item [ 'distance' ] + \\ distance_between_3d_points ( current_coord [ 0 ] , current_coord [ 1 ] , abs ( current_height ), nb_coord [ 0 ] , nb_coord [ 1 ] , abs ( nb_height ) ) if nb_coord_hashable not in shortest_paths_dict : shortest_paths_dict [ nb_coord_hashable ] = {} else : if nb_distance > shortest_paths_dict [ nb_coord_hashable ][ 'distance' ] : continue nb_coord_item = shortest_paths_dict [ nb_coord_hashable ] nb_coord_item [ 'distance' ] = nb_distance nb_coord_item [ 'path' ] = shortest_paths_dict [ current_coord_hash ][ 'path' ][ : ] nb_coord_item [ 'path' ] . append ( nb_coord ) if can_uav_land ( nb_label ) : nb_coord_item [ 'can_uav_land' ] = True else : nb_coord_item [ 'can_uav_land' ] = False find_landing_zone_re ( nb_coord , data , shortest_paths_dict , base_neighbours ) hashable_coord def hashable_coord ( coord ) Transforms a coord list into a hashable type. Parameters: Name Type Description Default coord list 2D coordinate i.e (0,0). None Returns: Type Description str A representation of the coord that is hashable. View Source def hashable_coord ( coord ): \"\"\"Transforms a coord list into a hashable type. Parameters ---------- coord : list 2D coordinate i.e (0,0). Returns ------- str A representation of the coord that is hashable. \"\"\" return str ( coord )","title":"Graph Utils"},{"location":"reference/landing_zone_detection/graph_utils/#module-landing_zone_detectiongraph_utils","text":"None None View Source import numpy as np from landing_zone_detection.label_utils import can_a_person_reach , can_uav_land def do_coord_exist ( coord , matrix_shape ): \"\"\"Check if a 2D coordinate isn't out of bounds. Parameters ---------- coord : numpy.ndarray 2D coordinate. matrix_shape : numpy.ndarray Shape of the matrix to where the coordinate should point. Returns ------- bool Whether the coordinate exists. \"\"\" return np . bitwise_and ( coord < matrix_shape , coord >= 0 ) . all () def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ): \"\"\"Computes the euclidean distance between two 3D points. Parameters ---------- x1 : int or float x coordinate of point 1. y1 : int or float y coordinate of point 1`. z1 : int or float z coordinate of point 1`. x2 : int or float x coordinate of point 2`. y2 : int or float y coordinate of point 2`. z2 : int or float z coordinate of point 2`. Returns ------- int or float Euclidean distance between two 3D points.. \"\"\" return (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) ** ( 1 / 2 ) def hashable_coord ( coord ): \"\"\"Transforms a coord list into a hashable type. Parameters ---------- coord : list 2D coordinate i.e (0,0). Returns ------- str A representation of the coord that is hashable. \"\"\" return str ( coord ) def find_landing_zone ( data ): \"\"\"Find the landing zone closest to the person xy coordinates considering the z terrain elevation.. Parameters ---------- data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). Returns ------- (list, int) Returns the shortest_path and the shortest_distance as a tuple. \"\"\" shortest_paths_dict = {} person_coord_hash = hashable_coord ( data . person_coord ) shortest_paths_dict [ person_coord_hash ] = {} shortest_paths_dict [ person_coord_hash ][ 'path' ] = [ data . person_coord ] shortest_paths_dict [ person_coord_hash ][ 'distance' ] = 0 base_neighbours = np . asarray ([[ 1 , 0 ], [ 0 , 1 ], [ 1 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ], [ - 1 , - 1 ], [ - 1 , 1 ], [ 1 , - 1 ]]) find_landing_zone_re ( data . person_coord , data , shortest_paths_dict , base_neighbours ) del shortest_paths_dict [ person_coord_hash ] for value in shortest_paths_dict . values (): if not value [ 'can_uav_land' ]: continue if 'shortest_distance' not in locals (): shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] continue if shortest_distance > value [ 'distance' ]: shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] if 'shortest_distance' in locals (): return shortest_path , shortest_distance else : return [], - 1 def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ): \"\"\"Recursive part of find_landing_zone. Parameters ---------- data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). Returns ------- (list, int) Returns the shortest_path and the shortest_distance as a tuple. Parameters ---------- current_coord : type Description of parameter `current_coord`. data : type Description of parameter `data`. shortest_paths_dict : type Description of parameter `shortest_paths_dict`. base_neighbours : type Description of parameter `base_neighbours`. Returns ------- type Description of returned object. \"\"\" current_coord_hash = hashable_coord ( current_coord ) current_height = data . height_map [ current_coord [ 0 ]][ current_coord [ 1 ]] current_item = shortest_paths_dict [ current_coord_hash ] neighbour_list = base_neighbours + np . asarray ( current_coord ) for nb_coord in neighbour_list : # ignore coords that do not exist i.e (-1, 99999999) if not do_coord_exist ( nb_coord , data . adj_matrix . shape ): continue nb_label = data . adj_matrix [ nb_coord [ 0 ]][ nb_coord [ 1 ]] # ignore unreachable coords if not can_a_person_reach ( nb_label ): continue nb_coord_hashable = hashable_coord ( nb_coord ) nb_height = data . height_map [ nb_coord [ 0 ]][ nb_coord [ 1 ]] nb_distance = current_item [ 'distance' ] + \\ distance_between_3d_points ( current_coord [ 0 ], current_coord [ 1 ], abs ( current_height ), nb_coord [ 0 ], nb_coord [ 1 ], abs ( nb_height ) ) if nb_coord_hashable not in shortest_paths_dict : shortest_paths_dict [ nb_coord_hashable ] = {} else : if nb_distance > shortest_paths_dict [ nb_coord_hashable ][ 'distance' ]: continue nb_coord_item = shortest_paths_dict [ nb_coord_hashable ] nb_coord_item [ 'distance' ] = nb_distance nb_coord_item [ 'path' ] = shortest_paths_dict [ current_coord_hash ][ 'path' ][:] nb_coord_item [ 'path' ] . append ( nb_coord ) if can_uav_land ( nb_label ): nb_coord_item [ 'can_uav_land' ] = True else : nb_coord_item [ 'can_uav_land' ] = False find_landing_zone_re ( nb_coord , data , shortest_paths_dict , base_neighbours )","title":"Module landing_zone_detection.graph_utils"},{"location":"reference/landing_zone_detection/graph_utils/#functions","text":"","title":"Functions"},{"location":"reference/landing_zone_detection/graph_utils/#distance_between_3d_points","text":"def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ) Computes the euclidean distance between two 3D points. Parameters: Name Type Description Default x1 int or float x coordinate of point 1. None y1 int or float y coordinate of point 1`. None z1 int or float z coordinate of point 1`. None x2 int or float x coordinate of point 2`. None y2 int or float y coordinate of point 2`. None z2 int or float z coordinate of point 2`. None Returns: Type Description int or float Euclidean distance between two 3D points.. View Source def distance_between_3d_points ( x1 , y1 , z1 , x2 , y2 , z2 ): \"\"\"Computes the euclidean distance between two 3D points. Parameters ---------- x1 : int or float x coordinate of point 1. y1 : int or float y coordinate of point 1`. z1 : int or float z coordinate of point 1`. x2 : int or float x coordinate of point 2`. y2 : int or float y coordinate of point 2`. z2 : int or float z coordinate of point 2`. Returns ------- int or float Euclidean distance between two 3D points.. \"\"\" return (( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) ** ( 1 / 2 )","title":"distance_between_3d_points"},{"location":"reference/landing_zone_detection/graph_utils/#do_coord_exist","text":"def do_coord_exist ( coord , matrix_shape ) Check if a 2D coordinate isn't out of bounds. Parameters: Name Type Description Default coord numpy.ndarray 2D coordinate. None matrix_shape numpy.ndarray Shape of the matrix to where the coordinate should point. None Returns: Type Description bool Whether the coordinate exists. View Source def do_coord_exist ( coord , matrix_shape ): \"\"\"Check if a 2D coordinate isn't out of bounds. Parameters ---------- coord : numpy.ndarray 2D coordinate. matrix_shape : numpy.ndarray Shape of the matrix to where the coordinate should point. Returns ------- bool Whether the coordinate exists. \"\"\" return np . bitwise_and ( coord < matrix_shape , coord >= 0 ). all ()","title":"do_coord_exist"},{"location":"reference/landing_zone_detection/graph_utils/#find_landing_zone","text":"def find_landing_zone ( data ) Find the landing zone closest to the person xy coordinates considering the z terrain elevation.. Parameters: Name Type Description Default data AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). None Returns: Type Description (list, int) Returns the shortest_path and the shortest_distance as a tuple. View Source def find_landing_zone ( data ) : \"\"\"Find the landing zone closest to the person xy coordinates considering the z terrain elevation.. Parameters ---------- data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). Returns ------- (list, int) Returns the shortest_path and the shortest_distance as a tuple. \"\"\" shortest_paths_dict = {} person_coord_hash = hashable_coord ( data . person_coord ) shortest_paths_dict [ person_coord_hash ] = {} shortest_paths_dict [ person_coord_hash ][ 'path' ] = [ data.person_coord ] shortest_paths_dict [ person_coord_hash ][ 'distance' ] = 0 base_neighbours = np . asarray ( [ [1, 0 ] , [ 0, 1 ] , [ 1, 1 ] , [ -1, 0 ] , [ 0, -1 ] , [ -1, -1 ] , [ -1, 1 ] , [ 1, -1 ] ] ) find_landing_zone_re ( data . person_coord , data , shortest_paths_dict , base_neighbours ) del shortest_paths_dict [ person_coord_hash ] for value in shortest_paths_dict . values () : if not value [ 'can_uav_land' ] : continue if 'shortest_distance' not in locals () : shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] continue if shortest_distance > value [ 'distance' ] : shortest_path = value [ 'path' ] shortest_distance = value [ 'distance' ] if 'shortest_distance' in locals () : return shortest_path , shortest_distance else : return [] , - 1","title":"find_landing_zone"},{"location":"reference/landing_zone_detection/graph_utils/#find_landing_zone_re","text":"def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ) Recursive part of find_landing_zone. Parameters: Name Type Description Default data AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). None current_coord type Description of parameter current_coord . None data type Description of parameter data . None shortest_paths_dict type Description of parameter shortest_paths_dict . None base_neighbours type Description of parameter base_neighbours . None Returns: Type Description (list, int) Returns the shortest_path and the shortest_distance as a tuple. View Source def find_landing_zone_re ( current_coord , data , shortest_paths_dict , base_neighbours ) : \"\"\"Recursive part of find_landing_zone. Parameters ---------- data : AerialImageData Aerial image and its surrounding data (frame, adj_matrix, height_map and person_coord). Returns ------- (list, int) Returns the shortest_path and the shortest_distance as a tuple. Parameters ---------- current_coord : type Description of parameter `current_coord`. data : type Description of parameter `data`. shortest_paths_dict : type Description of parameter `shortest_paths_dict`. base_neighbours : type Description of parameter `base_neighbours`. Returns ------- type Description of returned object. \"\"\" current_coord_hash = hashable_coord ( current_coord ) current_height = data . height_map [ current_coord[0 ] ] [ current_coord[1 ] ] current_item = shortest_paths_dict [ current_coord_hash ] neighbour_list = base_neighbours + np . asarray ( current_coord ) for nb_coord in neighbour_list : # ignore coords that do not exist i . e ( - 1 , 99999999 ) if not do_coord_exist ( nb_coord , data . adj_matrix . shape ) : continue nb_label = data . adj_matrix [ nb_coord[0 ] ] [ nb_coord[1 ] ] # ignore unreachable coords if not can_a_person_reach ( nb_label ) : continue nb_coord_hashable = hashable_coord ( nb_coord ) nb_height = data . height_map [ nb_coord[0 ] ] [ nb_coord[1 ] ] nb_distance = current_item [ 'distance' ] + \\ distance_between_3d_points ( current_coord [ 0 ] , current_coord [ 1 ] , abs ( current_height ), nb_coord [ 0 ] , nb_coord [ 1 ] , abs ( nb_height ) ) if nb_coord_hashable not in shortest_paths_dict : shortest_paths_dict [ nb_coord_hashable ] = {} else : if nb_distance > shortest_paths_dict [ nb_coord_hashable ][ 'distance' ] : continue nb_coord_item = shortest_paths_dict [ nb_coord_hashable ] nb_coord_item [ 'distance' ] = nb_distance nb_coord_item [ 'path' ] = shortest_paths_dict [ current_coord_hash ][ 'path' ][ : ] nb_coord_item [ 'path' ] . append ( nb_coord ) if can_uav_land ( nb_label ) : nb_coord_item [ 'can_uav_land' ] = True else : nb_coord_item [ 'can_uav_land' ] = False find_landing_zone_re ( nb_coord , data , shortest_paths_dict , base_neighbours )","title":"find_landing_zone_re"},{"location":"reference/landing_zone_detection/graph_utils/#hashable_coord","text":"def hashable_coord ( coord ) Transforms a coord list into a hashable type. Parameters: Name Type Description Default coord list 2D coordinate i.e (0,0). None Returns: Type Description str A representation of the coord that is hashable. View Source def hashable_coord ( coord ): \"\"\"Transforms a coord list into a hashable type. Parameters ---------- coord : list 2D coordinate i.e (0,0). Returns ------- str A representation of the coord that is hashable. \"\"\" return str ( coord )","title":"hashable_coord"},{"location":"reference/landing_zone_detection/label_utils/","text":"Module landing_zone_detection.label_utils None None View Source UAV_CAN_LAND_PERSON_CAN_REACH = 1 UAV_CANNOT_LAND_PERSON_CAN_REACH = 0 UAV_CANNOT_LAND_PERSON_CANNOT_REACH = - 1 def can_uav_land ( label ) : \" \"\" Checks if an UAV can reach a position labelled with \" label \". Parameters ---------- <<<<<<< HEAD label : int Label of a position in the image. Returns ------- boolean Whether an UAV can reach a position labelled with \" label \". ======= label : Int, default=Required . Returns ------- Boolean Boolean that indicates if a person can reach the frame. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH def can_a_person_reach ( label ) : \" \"\" Checks if a person can reach a position labelled with \" label \". Parameters ---------- <<<<<<< HEAD label : int Label of a position in the image. Returns ------- bool Whether a person can reach a position labelled with \" label \". ======= label : Int, default=Required Description of parameter `label`. Returns ------- Boolean Boolean that indicates if a porsan can reach the frame. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH or \\ label == UAV_CANNOT_LAND_PERSON_CAN_REACH Variables UAV_CANNOT_LAND_PERSON_CANNOT_REACH UAV_CANNOT_LAND_PERSON_CAN_REACH UAV_CAN_LAND_PERSON_CAN_REACH Functions can_a_person_reach def can_a_person_reach ( label ) Checks if a person can reach a position labelled with \"label\". Parameters ---------- <<<<<<< HEAD label : int Label of a position in the image. Returns ------- bool Whether a person can reach a position labelled with \"label\". ======= label : Int, default=Required Description of parameter label . Returns ------- Boolean Boolean that indicates if a porsan can reach the frame. babf6803825d127003e989374de11514beea5d59 View Source def can_a_person_reach ( label ) : \" \"\" Checks if a person can reach a position labelled with \" label \". Parameters ---------- <<<<<<< HEAD label : int Label of a position in the image. Returns ------- bool Whether a person can reach a position labelled with \" label \". ======= label : Int, default=Required Description of parameter `label`. Returns ------- Boolean Boolean that indicates if a porsan can reach the frame. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH or \\ label == UAV_CANNOT_LAND_PERSON_CAN_REACH can_uav_land def can_uav_land ( label ) Checks if an UAV can reach a position labelled with \"label\". Parameters ---------- <<<<<<< HEAD label : int Label of a position in the image. Returns ------- boolean Whether an UAV can reach a position labelled with \"label\". ======= label : Int, default=Required . Returns ------- Boolean Boolean that indicates if a person can reach the frame. babf6803825d127003e989374de11514beea5d59 View Source def can_uav_land ( label ): \"\"\"Checks if an UAV can reach a position labelled with \" label \". Parameters ---------- <<<<<<< HEAD label : int Label of a position in the image. Returns ------- boolean Whether an UAV can reach a position labelled with \" label \". ======= label : Int, default=Required . Returns ------- Boolean Boolean that indicates if a person can reach the frame. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return label == UAV_CAN_LAND_PERSON_CAN_REACH","title":"Label Utils"},{"location":"reference/landing_zone_detection/label_utils/#module-landing_zone_detectionlabel_utils","text":"None None View Source UAV_CAN_LAND_PERSON_CAN_REACH = 1 UAV_CANNOT_LAND_PERSON_CAN_REACH = 0 UAV_CANNOT_LAND_PERSON_CANNOT_REACH = - 1 def can_uav_land ( label ) : \" \"\" Checks if an UAV can reach a position labelled with \" label \". Parameters ---------- <<<<<<< HEAD label : int Label of a position in the image. Returns ------- boolean Whether an UAV can reach a position labelled with \" label \". ======= label : Int, default=Required . Returns ------- Boolean Boolean that indicates if a person can reach the frame. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH def can_a_person_reach ( label ) : \" \"\" Checks if a person can reach a position labelled with \" label \". Parameters ---------- <<<<<<< HEAD label : int Label of a position in the image. Returns ------- bool Whether a person can reach a position labelled with \" label \". ======= label : Int, default=Required Description of parameter `label`. Returns ------- Boolean Boolean that indicates if a porsan can reach the frame. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH or \\ label == UAV_CANNOT_LAND_PERSON_CAN_REACH","title":"Module landing_zone_detection.label_utils"},{"location":"reference/landing_zone_detection/label_utils/#variables","text":"UAV_CANNOT_LAND_PERSON_CANNOT_REACH UAV_CANNOT_LAND_PERSON_CAN_REACH UAV_CAN_LAND_PERSON_CAN_REACH","title":"Variables"},{"location":"reference/landing_zone_detection/label_utils/#functions","text":"","title":"Functions"},{"location":"reference/landing_zone_detection/label_utils/#can_a_person_reach","text":"def can_a_person_reach ( label ) Checks if a person can reach a position labelled with \"label\". Parameters ---------- <<<<<<< HEAD label : int Label of a position in the image. Returns ------- bool Whether a person can reach a position labelled with \"label\". ======= label : Int, default=Required Description of parameter label . Returns ------- Boolean Boolean that indicates if a porsan can reach the frame. babf6803825d127003e989374de11514beea5d59 View Source def can_a_person_reach ( label ) : \" \"\" Checks if a person can reach a position labelled with \" label \". Parameters ---------- <<<<<<< HEAD label : int Label of a position in the image. Returns ------- bool Whether a person can reach a position labelled with \" label \". ======= label : Int, default=Required Description of parameter `label`. Returns ------- Boolean Boolean that indicates if a porsan can reach the frame. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\" \" return label == UAV_CAN_LAND_PERSON_CAN_REACH or \\ label == UAV_CANNOT_LAND_PERSON_CAN_REACH","title":"can_a_person_reach"},{"location":"reference/landing_zone_detection/label_utils/#can_uav_land","text":"def can_uav_land ( label ) Checks if an UAV can reach a position labelled with \"label\". Parameters ---------- <<<<<<< HEAD label : int Label of a position in the image. Returns ------- boolean Whether an UAV can reach a position labelled with \"label\". ======= label : Int, default=Required . Returns ------- Boolean Boolean that indicates if a person can reach the frame. babf6803825d127003e989374de11514beea5d59 View Source def can_uav_land ( label ): \"\"\"Checks if an UAV can reach a position labelled with \" label \". Parameters ---------- <<<<<<< HEAD label : int Label of a position in the image. Returns ------- boolean Whether an UAV can reach a position labelled with \" label \". ======= label : Int, default=Required . Returns ------- Boolean Boolean that indicates if a person can reach the frame. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return label == UAV_CAN_LAND_PERSON_CAN_REACH","title":"can_uav_land"},{"location":"reference/landing_zone_detection/visualization_utils/","text":"Module landing_zone_detection.visualization_utils None None View Source import cv2 import numpy as np import matplotlib.pyplot as plt def item_from_color ( color , col_size = 32 , row_size = 32 ): \"\"\"Generates a matrix of size (col_size, row_size, len(color)) if color is 1D or a matrix of size (col_size, row_size) if color is a digit. Parameters ---------- <<<<<<< HEAD color : int or list RGB, gray or binary color i.e [255,255,255], 255 or 1. Maybe even RGBA or whatever. col_size : int Color size. row_size : int ======= color : List, default=Required List with 3 int that describe rgb color. col_size : Int, default=32 Color size. row_size : Int, default=32 >>>>>>> babf6803825d127003e989374de11514beea5d59 Size of a row. Returns ------- <<<<<<< HEAD numpy.ndarray 2D matrix representing an image. ======= ndarray Output array which has the same shape as color. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return np . repeat ( [ np . repeat ([ color ], col_size , axis = 0 )], row_size , axis = 0 ) def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ], 0 : [ 168 , 50 , 125 ], - 1 : [ 0 , 0 , 255 ]}, num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- <<<<<<< HEAD adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. value_to_color : dict Dict to map each value in the adj_matrix to a differenct color. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. ======= adj_matrix : ndarray, default=Required Adjacency matrix. value_to_color : dict Dict with colors of wich tipo of terrain. num_cols : int, default=7 number of columns. num_rows : type, default=7 number of rows. col_size : type, default=32 Size of columns. row_size : type, default=32 number of rows. img_dtype : type, default=np.uint8 Data type of image. Returns ------- type Image. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) value_to_item = { 1 : item_from_color ( value_to_color [ 1 ]), 0 : item_from_color ( value_to_color [ 0 ]), - 1 : item_from_color ( value_to_color [ - 1 ]), } for i , col in enumerate ( adj_matrix ): x1 = col_size * i x2 = col_size * ( i + 1 ) for j , value in enumerate ( col ): y1 = row_size * j y2 = row_size * ( j + 1 ) img [ x1 : x2 , y1 : y2 , :] = value_to_item [ value ] . copy () return img def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- <<<<<<< HEAD node_list : list List of node coordinates i.e [(0,0), (0,1), (0,2), (1,2)]. item_color : list Color of each node/item. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. ======= node_list : List list of nodes. item_color : List Item Color`. num_cols : Int Number of colors. num_rows : int Number of rows. col_size : int Color size. row_size : int Row size. img_dtype : int image Data type`. >>>>>>> babf6803825d127003e989374de11514beea5d59 Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) item = item_from_color ( item_color ) for node in node_list : x1 = col_size * node [ 0 ] x2 = col_size * ( node [ 0 ] + 1 ) y1 = row_size * node [ 1 ] y2 = row_size * ( node [ 1 ] + 1 ) img [ x1 : x2 , y1 : y2 , :] = item . copy () return img def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = []): \"\"\"Method to plot the frame. Parameters ---------- <<<<<<< HEAD frame : numpy.ndarray 2D matrix representing an image. width : int Frame width. height : int Frame height. images_to_overlay : list List of images to overlay on top of the frame. ======= frame : type Description of parameter `frame`. width : Int Frame width. height : Int Frame height. images_to_overlay : List List of frame to overlay. Returns ------- None >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" # overlay images on the frame if images_to_overlay : img_to_overlay = images_to_overlay [ 0 ] for img in images_to_overlay [ 1 :]: img_to_overlay += img if images_to_overlay : frame = cv2 . addWeighted ( img_to_overlay , 1.0 , frame , 1.0 , 0.0 ) # resize to desired size with bilinear interpolation frame = cv2 . resize ( frame , ( width , height ), interpolation = cv2 . INTER_LINEAR ) # convert from BGR to RGB for plotting purposes frame = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2RGB ) # plot the resulting frame plt . imshow ( frame ) plt . show () Functions adj_matrix_to_image def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ], 0 : [ 168 , 50 , 125 ], - 1 : [ 0 , 0 , 255 ]}, num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype =< class ' numpy . uint8 '> ) Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- <<<<<<< HEAD adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. value_to_color : dict Dict to map each value in the adj_matrix to a differenct color. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. ======= adj_matrix : ndarray, default=Required Adjacency matrix. value_to_color : dict Dict with colors of wich tipo of terrain. num_cols : int, default=7 number of columns. num_rows : type, default=7 number of rows. col_size : type, default=32 Size of columns. row_size : type, default=32 number of rows. img_dtype : type, default=np.uint8 Data type of image. Returns ------- type Image. babf6803825d127003e989374de11514beea5d59 View Source def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80, 30, 50 ] , 0 : [ 168, 50, 125 ] , - 1 : [ 0, 0, 255 ] } , num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ) : \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- <<<<<<< HEAD adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. value_to_color : dict Dict to map each value in the adj_matrix to a differenct color. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. ======= adj_matrix : ndarray, default=Required Adjacency matrix. value_to_color : dict Dict with colors of wich tipo of terrain. num_cols : int, default=7 number of columns. num_rows : type, default=7 number of rows. col_size : type, default=32 Size of columns. row_size : type, default=32 number of rows. img_dtype : type, default=np.uint8 Data type of image. Returns ------- type Image. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) value_to_item = { 1 : item_from_color ( value_to_color [ 1 ] ), 0 : item_from_color ( value_to_color [ 0 ] ), - 1 : item_from_color ( value_to_color [ -1 ] ), } for i , col in enumerate ( adj_matrix ) : x1 = col_size * i x2 = col_size * ( i + 1 ) for j , value in enumerate ( col ) : y1 = row_size * j y2 = row_size * ( j + 1 ) img [ x1:x2, y1:y2, : ] = value_to_item [ value ] . copy () return img item_from_color def item_from_color ( color , col_size = 32 , row_size = 32 ) Generates a matrix of size (col_size, row_size, len(color)) if color is 1D or a matrix of size (col_size, row_size) if color is a digit. Parameters ---------- <<<<<<< HEAD color : int or list RGB, gray or binary color i.e [255,255,255], 255 or 1. Maybe even RGBA or whatever. col_size : int Color size. row_size : int ======= color : List, default=Required List with 3 int that describe rgb color. col_size : Int, default=32 Color size. row_size : Int, default=32 babf6803825d127003e989374de11514beea5d59 Size of a row. Returns ------- <<<<<<< HEAD numpy.ndarray 2D matrix representing an image. ======= ndarray Output array which has the same shape as color. babf6803825d127003e989374de11514beea5d59 View Source def item_from_color ( color , col_size = 32 , row_size = 32 ) : \"\"\"Generates a matrix of size (col_size, row_size, len(color)) if color is 1D or a matrix of size (col_size, row_size) if color is a digit. Parameters ---------- <<<<<<< HEAD color : int or list RGB, gray or binary color i.e [255,255,255], 255 or 1. Maybe even RGBA or whatever. col_size : int Color size. row_size : int ======= color : List, default=Required List with 3 int that describe rgb color. col_size : Int, default=32 Color size. row_size : Int, default=32 >>>>>>> babf6803825d127003e989374de11514beea5d59 Size of a row. Returns ------- <<<<<<< HEAD numpy.ndarray 2D matrix representing an image. ======= ndarray Output array which has the same shape as color. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return np . repeat ( [ np.repeat([color ] , col_size , axis = 0 ) ] , row_size , axis = 0 ) node_list_to_image def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype =< class ' numpy . uint8 '> ) Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- <<<<<<< HEAD node_list : list List of node coordinates i.e [(0,0), (0,1), (0,2), (1,2)]. item_color : list Color of each node/item. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. ======= node_list : List list of nodes. item_color : List Item Color . num_cols : Int Number of colors. num_rows : int Number of rows. col_size : int Color size. row_size : int Row size. img_dtype : int image Data type . babf6803825d127003e989374de11514beea5d59 Returns ------- numpy.ndarray 2D matrix representing an image. View Source def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- <<<<<<< HEAD node_list : list List of node coordinates i.e [(0,0), (0,1), (0,2), (1,2)]. item_color : list Color of each node/item. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. ======= node_list : List list of nodes. item_color : List Item Color`. num_cols : Int Number of colors. num_rows : int Number of rows. col_size : int Color size. row_size : int Row size. img_dtype : int image Data type`. >>>>>>> babf6803825d127003e989374de11514beea5d59 Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) item = item_from_color ( item_color ) for node in node_list : x1 = col_size * node [ 0 ] x2 = col_size * ( node [ 0 ] + 1 ) y1 = row_size * node [ 1 ] y2 = row_size * ( node [ 1 ] + 1 ) img [ x1 : x2 , y1 : y2 , :] = item . copy () return img plot_frame def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = [] ) Method to plot the frame. Parameters ---------- <<<<<<< HEAD frame : numpy.ndarray 2D matrix representing an image. width : int Frame width. height : int Frame height. images_to_overlay : list List of images to overlay on top of the frame. ======= frame : type Description of parameter frame . width : Int Frame width. height : Int Frame height. images_to_overlay : List List of frame to overlay. Returns ------- None babf6803825d127003e989374de11514beea5d59 View Source def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = [] ) : \" \"\" Method to plot the frame. Parameters ---------- <<<<<<< HEAD frame : numpy.ndarray 2D matrix representing an image. width : int Frame width. height : int Frame height. images_to_overlay : list List of images to overlay on top of the frame. ======= frame : type Description of parameter `frame`. width : Int Frame width. height : Int Frame height. images_to_overlay : List List of frame to overlay. Returns ------- None >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\" \" # overlay images on the frame if images_to_overlay : img_to_overlay = images_to_overlay [ 0 ] for img in images_to_overlay [ 1 : ] : img_to_overlay += img if images_to_overlay : frame = cv2 . addWeighted ( img_to_overlay , 1.0 , frame , 1.0 , 0.0 ) # resize to desired size with bilinear interpolation frame = cv2 . resize ( frame , ( width , height ), interpolation = cv2 . INTER_LINEAR ) # convert from BGR to RGB for plotting purposes frame = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2RGB ) # plot the resulting frame plt . imshow ( frame ) plt . show ()","title":"Visualization Utils"},{"location":"reference/landing_zone_detection/visualization_utils/#module-landing_zone_detectionvisualization_utils","text":"None None View Source import cv2 import numpy as np import matplotlib.pyplot as plt def item_from_color ( color , col_size = 32 , row_size = 32 ): \"\"\"Generates a matrix of size (col_size, row_size, len(color)) if color is 1D or a matrix of size (col_size, row_size) if color is a digit. Parameters ---------- <<<<<<< HEAD color : int or list RGB, gray or binary color i.e [255,255,255], 255 or 1. Maybe even RGBA or whatever. col_size : int Color size. row_size : int ======= color : List, default=Required List with 3 int that describe rgb color. col_size : Int, default=32 Color size. row_size : Int, default=32 >>>>>>> babf6803825d127003e989374de11514beea5d59 Size of a row. Returns ------- <<<<<<< HEAD numpy.ndarray 2D matrix representing an image. ======= ndarray Output array which has the same shape as color. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return np . repeat ( [ np . repeat ([ color ], col_size , axis = 0 )], row_size , axis = 0 ) def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ], 0 : [ 168 , 50 , 125 ], - 1 : [ 0 , 0 , 255 ]}, num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- <<<<<<< HEAD adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. value_to_color : dict Dict to map each value in the adj_matrix to a differenct color. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. ======= adj_matrix : ndarray, default=Required Adjacency matrix. value_to_color : dict Dict with colors of wich tipo of terrain. num_cols : int, default=7 number of columns. num_rows : type, default=7 number of rows. col_size : type, default=32 Size of columns. row_size : type, default=32 number of rows. img_dtype : type, default=np.uint8 Data type of image. Returns ------- type Image. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) value_to_item = { 1 : item_from_color ( value_to_color [ 1 ]), 0 : item_from_color ( value_to_color [ 0 ]), - 1 : item_from_color ( value_to_color [ - 1 ]), } for i , col in enumerate ( adj_matrix ): x1 = col_size * i x2 = col_size * ( i + 1 ) for j , value in enumerate ( col ): y1 = row_size * j y2 = row_size * ( j + 1 ) img [ x1 : x2 , y1 : y2 , :] = value_to_item [ value ] . copy () return img def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- <<<<<<< HEAD node_list : list List of node coordinates i.e [(0,0), (0,1), (0,2), (1,2)]. item_color : list Color of each node/item. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. ======= node_list : List list of nodes. item_color : List Item Color`. num_cols : Int Number of colors. num_rows : int Number of rows. col_size : int Color size. row_size : int Row size. img_dtype : int image Data type`. >>>>>>> babf6803825d127003e989374de11514beea5d59 Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) item = item_from_color ( item_color ) for node in node_list : x1 = col_size * node [ 0 ] x2 = col_size * ( node [ 0 ] + 1 ) y1 = row_size * node [ 1 ] y2 = row_size * ( node [ 1 ] + 1 ) img [ x1 : x2 , y1 : y2 , :] = item . copy () return img def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = []): \"\"\"Method to plot the frame. Parameters ---------- <<<<<<< HEAD frame : numpy.ndarray 2D matrix representing an image. width : int Frame width. height : int Frame height. images_to_overlay : list List of images to overlay on top of the frame. ======= frame : type Description of parameter `frame`. width : Int Frame width. height : Int Frame height. images_to_overlay : List List of frame to overlay. Returns ------- None >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" # overlay images on the frame if images_to_overlay : img_to_overlay = images_to_overlay [ 0 ] for img in images_to_overlay [ 1 :]: img_to_overlay += img if images_to_overlay : frame = cv2 . addWeighted ( img_to_overlay , 1.0 , frame , 1.0 , 0.0 ) # resize to desired size with bilinear interpolation frame = cv2 . resize ( frame , ( width , height ), interpolation = cv2 . INTER_LINEAR ) # convert from BGR to RGB for plotting purposes frame = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2RGB ) # plot the resulting frame plt . imshow ( frame ) plt . show ()","title":"Module landing_zone_detection.visualization_utils"},{"location":"reference/landing_zone_detection/visualization_utils/#functions","text":"","title":"Functions"},{"location":"reference/landing_zone_detection/visualization_utils/#adj_matrix_to_image","text":"def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80 , 30 , 50 ], 0 : [ 168 , 50 , 125 ], - 1 : [ 0 , 0 , 255 ]}, num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype =< class ' numpy . uint8 '> ) Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- <<<<<<< HEAD adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. value_to_color : dict Dict to map each value in the adj_matrix to a differenct color. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. ======= adj_matrix : ndarray, default=Required Adjacency matrix. value_to_color : dict Dict with colors of wich tipo of terrain. num_cols : int, default=7 number of columns. num_rows : type, default=7 number of rows. col_size : type, default=32 Size of columns. row_size : type, default=32 number of rows. img_dtype : type, default=np.uint8 Data type of image. Returns ------- type Image. babf6803825d127003e989374de11514beea5d59 View Source def adj_matrix_to_image ( adj_matrix , value_to_color = { 1 : [ 80, 30, 50 ] , 0 : [ 168, 50, 125 ] , - 1 : [ 0, 0, 255 ] } , num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ) : \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- <<<<<<< HEAD adj_matrix : numpy.ndarray Adjacent matrix where the meaning of each value is specified in the label_utils.py module. value_to_color : dict Dict to map each value in the adj_matrix to a differenct color. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. Returns ------- numpy.ndarray 2D matrix representing an image. ======= adj_matrix : ndarray, default=Required Adjacency matrix. value_to_color : dict Dict with colors of wich tipo of terrain. num_cols : int, default=7 number of columns. num_rows : type, default=7 number of rows. col_size : type, default=32 Size of columns. row_size : type, default=32 number of rows. img_dtype : type, default=np.uint8 Data type of image. Returns ------- type Image. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) value_to_item = { 1 : item_from_color ( value_to_color [ 1 ] ), 0 : item_from_color ( value_to_color [ 0 ] ), - 1 : item_from_color ( value_to_color [ -1 ] ), } for i , col in enumerate ( adj_matrix ) : x1 = col_size * i x2 = col_size * ( i + 1 ) for j , value in enumerate ( col ) : y1 = row_size * j y2 = row_size * ( j + 1 ) img [ x1:x2, y1:y2, : ] = value_to_item [ value ] . copy () return img","title":"adj_matrix_to_image"},{"location":"reference/landing_zone_detection/visualization_utils/#item_from_color","text":"def item_from_color ( color , col_size = 32 , row_size = 32 ) Generates a matrix of size (col_size, row_size, len(color)) if color is 1D or a matrix of size (col_size, row_size) if color is a digit. Parameters ---------- <<<<<<< HEAD color : int or list RGB, gray or binary color i.e [255,255,255], 255 or 1. Maybe even RGBA or whatever. col_size : int Color size. row_size : int ======= color : List, default=Required List with 3 int that describe rgb color. col_size : Int, default=32 Color size. row_size : Int, default=32 babf6803825d127003e989374de11514beea5d59 Size of a row. Returns ------- <<<<<<< HEAD numpy.ndarray 2D matrix representing an image. ======= ndarray Output array which has the same shape as color. babf6803825d127003e989374de11514beea5d59 View Source def item_from_color ( color , col_size = 32 , row_size = 32 ) : \"\"\"Generates a matrix of size (col_size, row_size, len(color)) if color is 1D or a matrix of size (col_size, row_size) if color is a digit. Parameters ---------- <<<<<<< HEAD color : int or list RGB, gray or binary color i.e [255,255,255], 255 or 1. Maybe even RGBA or whatever. col_size : int Color size. row_size : int ======= color : List, default=Required List with 3 int that describe rgb color. col_size : Int, default=32 Color size. row_size : Int, default=32 >>>>>>> babf6803825d127003e989374de11514beea5d59 Size of a row. Returns ------- <<<<<<< HEAD numpy.ndarray 2D matrix representing an image. ======= ndarray Output array which has the same shape as color. >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\"\" return np . repeat ( [ np.repeat([color ] , col_size , axis = 0 ) ] , row_size , axis = 0 )","title":"item_from_color"},{"location":"reference/landing_zone_detection/visualization_utils/#node_list_to_image","text":"def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype =< class ' numpy . uint8 '> ) Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- <<<<<<< HEAD node_list : list List of node coordinates i.e [(0,0), (0,1), (0,2), (1,2)]. item_color : list Color of each node/item. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. ======= node_list : List list of nodes. item_color : List Item Color . num_cols : Int Number of colors. num_rows : int Number of rows. col_size : int Color size. row_size : int Row size. img_dtype : int image Data type . babf6803825d127003e989374de11514beea5d59 Returns ------- numpy.ndarray 2D matrix representing an image. View Source def node_list_to_image ( node_list , item_color = [ 255 , 0 , 0 ], num_channels = 3 , num_cols = 7 , num_rows = 7 , col_size = 32 , row_size = 32 , img_dtype = np . uint8 ): \"\"\"Convert a node list to an image. Do that by coloring the image items at the coordinates in the node_list. Parameters ---------- <<<<<<< HEAD node_list : list List of node coordinates i.e [(0,0), (0,1), (0,2), (1,2)]. item_color : list Color of each node/item. num_cols : int Number of columns in each adj_matrix (or height_map) item. num_rows : int Number of rows in each adj_matrix (or height_map) item. col_size : int Width of each adj_matrix (or height_map) item. row_size : int Height of each adj_matrix (or height_map) item. img_dtype : int Data type of the resulting image. ======= node_list : List list of nodes. item_color : List Item Color`. num_cols : Int Number of colors. num_rows : int Number of rows. col_size : int Color size. row_size : int Row size. img_dtype : int image Data type`. >>>>>>> babf6803825d127003e989374de11514beea5d59 Returns ------- numpy.ndarray 2D matrix representing an image. \"\"\" img = np . zeros ( ( num_cols * col_size , num_rows * row_size , num_channels ), dtype = img_dtype ) item = item_from_color ( item_color ) for node in node_list : x1 = col_size * node [ 0 ] x2 = col_size * ( node [ 0 ] + 1 ) y1 = row_size * node [ 1 ] y2 = row_size * ( node [ 1 ] + 1 ) img [ x1 : x2 , y1 : y2 , :] = item . copy () return img","title":"node_list_to_image"},{"location":"reference/landing_zone_detection/visualization_utils/#plot_frame","text":"def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = [] ) Method to plot the frame. Parameters ---------- <<<<<<< HEAD frame : numpy.ndarray 2D matrix representing an image. width : int Frame width. height : int Frame height. images_to_overlay : list List of images to overlay on top of the frame. ======= frame : type Description of parameter frame . width : Int Frame width. height : Int Frame height. images_to_overlay : List List of frame to overlay. Returns ------- None babf6803825d127003e989374de11514beea5d59 View Source def plot_frame ( frame , width = 224 , height = 224 , images_to_overlay = [] ) : \" \"\" Method to plot the frame. Parameters ---------- <<<<<<< HEAD frame : numpy.ndarray 2D matrix representing an image. width : int Frame width. height : int Frame height. images_to_overlay : list List of images to overlay on top of the frame. ======= frame : type Description of parameter `frame`. width : Int Frame width. height : Int Frame height. images_to_overlay : List List of frame to overlay. Returns ------- None >>>>>>> babf6803825d127003e989374de11514beea5d59 \"\" \" # overlay images on the frame if images_to_overlay : img_to_overlay = images_to_overlay [ 0 ] for img in images_to_overlay [ 1 : ] : img_to_overlay += img if images_to_overlay : frame = cv2 . addWeighted ( img_to_overlay , 1.0 , frame , 1.0 , 0.0 ) # resize to desired size with bilinear interpolation frame = cv2 . resize ( frame , ( width , height ), interpolation = cv2 . INTER_LINEAR ) # convert from BGR to RGB for plotting purposes frame = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2RGB ) # plot the resulting frame plt . imshow ( frame ) plt . show ()","title":"plot_frame"}]}